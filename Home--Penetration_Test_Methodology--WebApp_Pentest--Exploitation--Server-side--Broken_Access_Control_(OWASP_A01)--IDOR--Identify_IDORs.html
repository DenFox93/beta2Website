<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Identify IDORs</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>Identify IDORs</h1><br/><br /><br /><strong>URL Parameters &amp; APIs</strong><br /> Whenever we receive a specific file or resource, we should study the HTTP requests to look for URL parameters or APIs with an object reference (e.g. ?uid=1 or ?filename=file_1.pdf).<br /> These are mostly found in URL parameters or APIs but may also be found in other HTTP headers, like cookies.<br /><br /><br /><strong><h3>AJAX Calls</h3></strong><br />Identify unused parameters or APIs in the front-end code in the form of JavaScript AJAX calls.<br />Some web applications developed in JavaScript frameworks may insecurely place all function calls on the front-end and use the appropriate ones based on the user role.<br /><span style="color:#986a44;">example:</span> if we did not have an admin account, only the user-level functions would be used, while the admin functions would be disabled. <br />	However, we may still be able to find the admin functions if we look into the front-end JavaScript code and may be able to identify AJAX calls to specific end-points or APIs that contain direct object references. If we identify direct object references in the JavaScript code, we can test them for IDOR vulnerabilities.<br />	This is not unique to admin functions, of course, but can also be any functions or calls that may not be found through monitoring HTTP requests. <br />	Code: javascript<br />	<div class="codebox"><pre>function changeUserPassword() {<br />    $.ajax({<br />        url:&quot;change_password.php&quot;,<br />        type: &quot;post&quot;,<br />        dataType: &quot;json&quot;,<br />        data: {uid: user.uid, password: user.password, is_admin: is_admin},<br />        success:function(result){<br />            //<br />        }<br />    });<br />}</pre></div><br />	The above function may never be called when we use the web application as a non-admin user. <br /><br /><strong><h3>Understand Hashing/Encoding</h3></strong><br />Some web applications may not use simple sequential numbers as object references but may encode the reference or hash it instead. If we find such parameters using encoded or hashed values, we may still be able to exploit them if there is no access control system on the back-end.<br /><span style="color:#986a44;">example 1:</span> Suppose the reference value is encoded with a common encoder (e.g. base64). In that case, we could decode it and view the plaintext of the object reference, change its value, and then encode it again to access other data. For example, if we see a reference like (?filename=ZmlsZV8xMjMucGRm), we can immediately guess that the file name is base64 encoded (from its character set), which we can decode to get the original object reference of (file_123.pdf). Then, we can try encoding a different object reference (e.g. file_124.pdf) and try accessing it with the encoded object reference (?filename=ZmlsZV8xMjQucGRm), which may reveal an IDOR vulnerability if we were able to retrieve any data.<br /><span style="color:#986a44;">example 2:</span> the object reference may be hashed, like (download.php?filename=c81e728d9d4c2f636f067f89cc14862c). At a first glance, we may think that this is a secure object reference, as it is not using any clear text or easy encoding. However, if we look at the source code, we may see what is being hashed before the API call is made:<br />	Code: javascript<br />	<div class="codebox"><pre>$.ajax({<br />    url:&quot;download.php&quot;,<br />    type: &quot;post&quot;,<br />    dataType: &quot;json&quot;,<br />    data: {filename: CryptoJS.MD5(&#39;file_1.pdf&#39;).toString()},<br />    success:function(result){<br />        //<br />    }<br />});</pre></div><code><br /></code><br />	In this case, we can see that code uses the filename and hashing it with CryptoJS.MD5, making it easy for us to calculate the filename for other potential files. Otherwise, we may manually try to identify the hashing algorithm being used (e.g., with hash identifier tools) and then hash the filename to see if it matches the used hash. Once we can calculate hashes for other files, we may try downloading them, which may reveal an IDOR vulnerability if we can download any files that do not belong to us.<br /><br /><strong><h3>Compare User Roles</h3></strong><br />We could also to register multiple users and compare their HTTP requests and object references.<br />This may allow us to understand how the URL parameters and unique identifiers are being calculated and then calculate them for other users to gather their data.<br /><span style="color:#986a44;">example:</span> if we had access to two different users, one of which can view their salary after making the following API call<br />	Code: json<br />	<div class="codebox"><pre>{<br />  &quot;attributes&quot; : <br />    {<br />      &quot;type&quot; : &quot;salary&quot;,<br />      &quot;url&quot; : &quot;/services/data/salaries/users/1&quot;<br />    },<br />  &quot;Id&quot; : &quot;1&quot;,<br />  &quot;Name&quot; : &quot;User1&quot;<br /><br />}<br /></pre></div><br /><br />	The second user may not have all of these API parameters to replicate the call and should not be able to make the same call as User1. However, with these details at hand, we can try repeating the same API call while logged in as User2 to see if the web application returns anything. <br />	Such cases may work if the web application only requires a valid logged-in session to make the API call but has no access control on the back-end to compare the caller&#39;s session with the data being called.<br /><br /></div>
</body>
</html>
