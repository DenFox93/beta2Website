<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Example: Fix with Simple Authorization</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>Example: Fix with Simple Authorization</h1><br/><br />So obviously it’s easy to understand we have functions we don’t want directly called.<br />To prevent this we need to implement some kind of protection scheme. Whether that is a:<br />   ◇  require statements for accounts<br />   ◇  more elaborate role-based designs<br />Anyway there are various ways we can implement authorization.<br /><br /><strong>Fix 1: add require statement</strong><br />Note → The <span style="text-decoration:underline;">kill function</span> is <span style="color:#ff0000;">highly suspect</span> as it removes all of the funds in the contract and could be indicative of an “exit scheme”.<span style="color:#393939;"> </span>Even if the developers did not intend to use the function maliciously, it opens the door for someone else to do so<br /><div class="codebox"><pre>pragma solidity ^0.6.6;<br /><br />contract simpleAuth2 {<br />    address owner;<br />    mapping (address =&gt;uint) balances;<br />    <br />    constructor() public {<br />      owner = msg.sender;                                       <span style="color:#0088ff;font-weight:400">//&lt;-- constructor sets the owner of the contract to the address </span><br />                                                                <span style="color:#0088ff;font-weight:400">// of the user who deployed the contract</span><br />    }<br />    <br />    function deposit() public payable{<br /> 	    balances[msg.sender] = balances[msg.sender]+msg.value;<br />    }<br />    <br />    function withdraw(uint amount) public payable {<br />        require (balances[msg.sender] &gt;= amount);                <span style="color:#0088ff;font-weight:400">//&lt;-- the amount in the account must be &gt;=nof the requested one</span><br />        msg.sender.transfer(amount);<br />    }<br />    <br />    function kill() public {<br />        require(msg.sender == owner);                            <span style="color:#0088ff;font-weight:400">//&lt;-- to use this function must be the owner</span><br />        selfdestruct(msg.sender);<br />    }<br />}</pre></div><br /><br /><br /><strong>Fix 2: Using Modifiers for Simple Authentication</strong><br />The use of modifiers let the code be more extendable, when we have to use a lot of functions that need authorization restrictions<br /><div class="codebox"><pre>pragma solidity ^0.6.6;<br /><br />contract simpleAuth2 {<br />    address owner;<br />    mapping (address =&gt;uint) balances;<br />    <br />    constructor() public {<br />      owner = msg.sender;<br />    }<br />    <br />    modifier onlyOwner() {                                        <span style="color:#0088ff;font-weight:400">//&lt;-- added modifier</span><br />        require(msg.sender == owner);<br />        _;                                                        <span style="color:#0088ff;font-weight:400">//&lt;-- continue running the function after this modifier code is finished</span><br />  }<br /><br />    function deposit() public payable{<br />        balances[msg.sender] = balances[msg.sender]+msg.value;<br />    }<br />    <br />    function withdraw(uint amount) public payable {<br />        require (balances[msg.sender] &gt;= amount);<br />        msg.sender.transfer(amount);<br />    }<br />    <br />    function kill() public onlyOwner{                              <span style="color:#0088ff;font-weight:400">//&lt;-- added modifier call in the definition of the function</span><br />        selfdestruct(msg.sender);<br />    }<br />}</pre></div><br /><br /><strong>Fix 3: Use OpenZeppelin functions</strong><br />Instead of create our own &quot;modifier onlyOwner()&quot; we can use the one of OpenZeppelin that is well-audited and open source.<br />WARNING: make sure to compile the code with the newest version of Solidity that OpenZepplin files are using(at the moment of writing 0.8.0 version of solidity). If versions change in the future you will get an error. In that case change the code and use the latest version of OpenZepplin files!<br />Github: <a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/AccessControl.sol">https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/AccessControl.sol</a><br />    <a href=""><img src="images/1424-1.png" alt="images/1424-1.png" /></a><br />    <a href=""><img src="images/1424-2.png" alt="images/1424-2.png" /></a><br />    <a href=""><img src="images/1424-3.png" alt="images/1424-3.png" /></a><br />    <a href=""><img src="images/1424-4.png" alt="images/1424-4.png" /></a><br />    <a href=""><img src="images/1424-5.png" alt="images/1424-5.png" /></a><br /><div class="codebox"><pre><span style="color:#0088ff;font-weight:400">// SPDX-License-Identifier: MIT</span><br /><br />pragma solidity ^0.8.0;<br />import <span style="color:#3ad900;font-weight:400">&quot;https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/AccessControl.sol&quot;</span>;<br /><br /><br />contract roleBased is AccessControl {<br />    <span style="color:#0088ff;font-weight:400">//user and admin role identifiers.</span><br />    <span style="color:#0088ff;font-weight:400">//If you take a look at the documentation link in the bibliography it states that the role identifier must be created as a bytes32 hash.</span><br />    <span style="color:#0088ff;font-weight:400">//keccak256 is essentially the equivalent of a sha3 hash function in Ethereum</span><br />    bytes32 public constant admin = keccak256(<span style="color:#3ad900;font-weight:400">&quot;admin&quot;</span>);<br />    bytes32 public constant user = keccak256(<span style="color:#3ad900;font-weight:400">&quot;user&quot;</span>);<br />    mapping (address =&gt;uint) balances;<br />    <br />    constructor() {<br />       _setupRole(admin, msg.sender);                                              <span style="color:#0088ff;font-weight:400">//&lt;---</span><br />    }<br />    <br /><br />    function deposit() public payable{<br />        <span style="color:#ff9d00;font-weight:700">if</span> (!(hasRole(admin, msg.sender))){                                        <span style="color:#0088ff;font-weight:400">//&lt;---</span><br />            _setupRole(user, msg.sender);                                          <span style="color:#0088ff;font-weight:400">//&lt;---</span><br />        }<br />        balances[msg.sender] = balances[msg.sender]+msg.value;<br />    }<br />    <br />    function withdraw(uint amount) public payable {<br />        require(hasRole(user, msg.sender), <span style="color:#3ad900;font-weight:400">&quot;Caller is not a user of this bank&quot;</span>);  <span style="color:#0088ff;font-weight:400">//&lt;--- if you have not already deposited funds</span><br />                                                                                  <span style="color:#0088ff;font-weight:400">//      you will not have a user role, so you cannot withdraw funds</span><br />        require (balances[msg.sender] &gt;= amount);<br />        <br />        payable(msg.sender).transfer(amount);<br />    }<br />    <br />    function kill() public {<br />        require(hasRole(admin, msg.sender), <span style="color:#3ad900;font-weight:400">&quot;Caller is not a administrator&quot;</span>);    <span style="color:#0088ff;font-weight:400">//&lt;---</span><br />        selfdestruct(payable(msg.sender));<br />    }<br />}</pre></div><br /><br />Bibliography:<br />• <a href="https://docs.openzeppelin.com/contracts/3.x/access-control">https://docs.openzeppelin.com/contracts/3.x/access-control</a></div>
</body>
</html>
