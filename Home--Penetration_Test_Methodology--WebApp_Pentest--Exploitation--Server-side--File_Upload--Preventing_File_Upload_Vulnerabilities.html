<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Preventing File Upload Vulnerabilities</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>Preventing File Upload Vulnerabilities</h1><br/><br /><br /><strong><h3>Extension Validation</h3></strong><br />• Whitelisting extensions is always more secure then blacklisting extensions<br />• It is recommended to use both by whitelisting the allowed extensions and blacklisting dangerous extensions.<br />   ◇  This way, the blacklist list will prevent uploading malicious scripts if the whitelist is ever bypassed (e.g. shell.php.jpg). <br />• Aply both back-end and front-end file validation<br />   ◇  Even if front-end validation can be easily bypassed, it reduces the chances of users uploading unintended files, thus potentially triggering a defense mechanism and sending us a false alert<br /><span style="color:#865e3c;">example of a PHP secure source code:Whitelisting + Blacklisting</span>	<div class="codebox"><pre>$fileName = basename($_FILES[&quot;uploadFile&quot;][&quot;name&quot;]);<br /><br />// blacklist test<br />// check if the extension exists anywhere within the file name<br />if (preg_match(&#39;/^.+\.ph(p|ps|ar|tml)/&#39;, $fileName)) {<br />    echo &quot;Only images are allowed&quot;;<br />    die();<br />}<br /><br />// whitelist test<br />// check  if the file name ends with the extension<br />if (!preg_match(&#39;/^.*\.(jpg|jpeg|png|gif)$/&#39;, $fileName)) {<br />    echo &quot;Only images are allowed&quot;;<br />    die();<br />}</pre></div><br /><br /><br /><strong><h3>Content Validation</h3></strong><br />With this we will validate the file content. <br />• must always validate both the file extension and its content<br />• always make sure that the file extension matches the file&#39;s content<br /><span style="color:#865e3c;">example of a PHP secure source code: file extension(whitelisting) + File Signature (MIME-Type) + HTTP Content-Type header validation</span><br />	<div class="codebox"><pre>$fileName = basename($_FILES[&quot;uploadFile&quot;][&quot;name&quot;]);<br />$contentType = $_FILES[&#39;uploadFile&#39;][&#39;type&#39;];<br />$MIMEtype = mime_content_type($_FILES[&#39;uploadFile&#39;][&#39;tmp_name&#39;]);<br /><br />// whitelist test<br />if (!preg_match(&#39;/^.*\.png$/&#39;, $fileName)) {<br />    echo &quot;Only PNG images are allowed&quot;;<br />    die();<br />}<br /><br />// content test<br />foreach (array($contentType, $MIMEtype) as $type) {<br />    if (!in_array($type, array(&#39;image/png&#39;))) {<br />        echo &quot;Only SVG images are allowed&quot;;<br />        die();<br />    }<br />}</pre></div><br />	<br /><br /><br /><strong><h3>Upload Disclosure</h3></strong><br />• avoid disclosure the uploads directory or providing direct access to the uploaded file<br />• recommended to hide the uploads directory from the end-users and only allow them to download the uploaded files through a download page.<br />• Use a &quot;download.php&quot; script to fetch the requested file from the uploads directory and then download the file for the end-user. <br />   ◇ This hides the uploads directory and prevents the user from directly accessing the uploaded file. <br />   ◇ This Significantly reduce the chances of accessing a maliciously uploaded script to execute code.<br />   ◇ Make sure that the &quot;download.php&quot; script only grants access to files owned by the users (i.e., avoid IDOR/LFI vulnerabilities) <br />   ◇ Make sure that the users do not have direct access to the uploads directory (i.e., 403 error). <br />      ▪ This can be achieved by utilizing:<br />         - the <code>Content-Disposition</code> header<br />         - the  <code>nosniff</code> header <br />         - the <code>Content-Type</code> header.<br />• randomize the names of the uploaded files in storage and store their &quot;sanitized&quot; original names in a database. <br />   ◇ When the &quot;download.php&quot; script needs to download a file, it fetches its original name from the database and provides it at download time for the user.<br />   ◇ This way, users will neither know the uploads directory nor the uploaded file name. <br />   ◇ This avoid vulnerabilities caused by injections in the file names, as we saw “<a href="Home--Penetration_Test_Methodology--WebApp_Pentest--Exploitation--Server-side--File_Upload--Other_Upload_Attacks--Injections_in_File_Name.html">Injections in File Name</a>”<br />• Store the uploaded files in a separate server or container. <br />   ◇ If an attacker can gain remote code execution, they would only compromise the uploads server, not the entire back-end server.<br />• Web servers can be configured to prevent web applications from accessing files outside their restricted directories by using configurations like (open_basedir) in PHP.<br /><br /><br /><br /><strong><h3>Further Security</h3></strong><br />• disable specific functions that may be used to execute system commands through the web application. <br />   ◇ <span style="text-decoration:underline;">PHP</span>: disable_functions configuration in &quot;php.ini&quot; and add these dangerous functions: exec, shell_exec, system, passthru,...<br />• disable showing any system or server errors, to avoid sensitive information disclosure<br />   Aalways handle errors at the web application level and print out simple errors that explain the error without disclosing any sensitive or specific details, like the file name, uploads directory, or the raw errors.<br />• Limit file size<br />• Update any used libraries<br />• Scan uploaded files for malware or malicious strings<br />• Utilize a Web Application Firewall (WAF) as a secondary layer of protection<br /><br /><br /><br />Bibliograhy:<br /><a href="https://academy.hackthebox.com/">https://academy.hackthebox.com/</a></div>
</body>
</html>
