<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>RSA Key Confusion (CVE-2016-5431)</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>RSA Key Confusion (CVE-2016-5431)</h1><br/><br /><strong>Change Algorithm</strong><br />JWT accepts both symmetric and asymmetric encryption algorithms. Depending on the encryption type, you need to use either a shared secret or a public-private key pair:<br /><table class="table"><tr><th>Algorithm</th><th>Key used to sign</th><th>Key used to verify</th></tr><tr><td>Asymmetric (RSA)</td><td>Private key</td><td>Public key</td></tr><tr><td>Symmetric (HMAC)</td><td>Shared secret</td><td>Shared secret</td></tr></table><br />• HS256 indicates that this token is signed using HMAC-SHA256<br />• RS256  indicates that this token is signed using RSA-SHA256<br /><br />When an application uses asymmetric encryption, it can openly publish its public key and keep the private key secret. This allows the application to sign tokens using its private key and anyone can verify this token using its public key. The algorithm confusion vulnerability arises when an application does not check whether the algorithm of the received token matches the expected algorithm.<br />In many JWT libraries, the method to verify the signature is:<br />◇ verify(token, secret) – if the token is signed with HMAC<br />◇ verify(token, publicKey) – if the token is signed with RSA or similar<br /><br />Unfortunately,<span style="text-decoration:underline;"> in some libraries, this method by itself does not check whether the received token is signed using the application’s expected algorithm</span>. That’s why in the case of HMAC this method will treat the second argument as a shared secret and in the case of RSA as a public key.<br />If the public key is accessible within the application, an attacker can forge malicious tokens by:<br />1. Changing the algorithm of the token to HMAC<br />	<a href=""><img src="images/2271-1.png" alt="images/2271-1.png" /></a><br />3. Tampering with the payload to get the desired outcome<br />4. Signing the malicious token with the public key found in the application<br />	<div class="codebox"><pre>jwt_tool &lt;JWT_Token&gt; -X k -pk public-key.pem</pre></div><br />	<a href=""><img src="images/2271-2.png" alt="images/2271-2.png" /></a><br />6. Sending the JWT back to the application<br />The application expects RSA encryption, so when an attacker supplies HMAC instead, the verify() method will treat the public key as an HMAC shared secret and use symmetric rather than asymmetric encryption. This means that the token will be signed using the application’s non-secret public key and then verified using the same public key.<br />To avoid this vulnerability, applications must check if the algorithm of the received token is the expected one before they pass the token to the verify() method.<br /><br />Using trivial secrets<br />With symmetric encryption, a cryptographic signature is only as strong as the secret used. If an application uses a weak secret, the attacker can simply brute-force it by trying different secret values until the original signature matches the forged one. Having discovered the secret, the attacker can use it to generate valid signatures for malicious tokens. To avoid this vulnerability, strong secrets must always be used with symmetric encryption.<br /><br /><br /><br /><br /><br />Bibliography:<br /><a href="https://www.invicti.com/blog/web-security/json-web-token-jwt-attacks-vulnerabilities/">https://www.invicti.com/blog/web-security/json-web-token-jwt-attacks-vulnerabilities/</a></div>
</body>
</html>
