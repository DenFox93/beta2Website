<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Prevention & Mitigation</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>Prevention & Mitigation</h1><br/><br /><br /><strong><h3>System Commands</h3></strong><br />• <span style="text-decoration:underline;">Always avoid using functions that execute system commands</span>, especially if we are using user input with them. <br />   ◇ Even when we are not directly inputting user input into these functions, a user may be able to indirectly influence them, which may eventually lead to a command injection vulnerability.<br />• Instead of using system command execution functions, we should <span style="text-decoration:underline;">use built-in functions that perform the needed functionality</span>, as back-end languages usually have secure implementations of these types of functionalities. <br />   ◇ <span style="color:#a52a2a;">example PHP</span>: suppose we wanted to test whether a particular host is alive with PHP. In that case, we may use the &quot;fsockopen&quot; function instead, which should not be exploitable to execute arbitrary system commands.<br />• If we really need to execute a system command, and no built-in function can be found to perform the same functionality:<br />   ◇ we should never directly use the user input with these functions but <span style="color:#ffa500;text-decoration:underline;">always validate</span> and <span style="color:#a020f0;">sanitize</span> the user input on the back-end. <br />   ◇ limit our use of these types of functions as much as possible and only use them when there&#39;s no built-in alternative to the functionality we require.<br /><br /><br /><strong><h3>Input Validation</h3></strong><br />• Whether using built-in functions or system command execution functions, we should always validate and then sanitize the user input. Input validation is done to ensure it matches the expected format for the input, such that the request is denied if it does not match. <br />• Input validation should be done both on the front-end and on the back-end.<br />• For most of the web development languages, there are built in filters for a variety of standard formats, like emails, URLs, and even IPs<br />   ◇ PHP: filter_var()<br />   ◇ Node.js:  <a href="https://www.npmjs.com/package/is-ip">is-ip()</a><br /><span style="color:#a52a2a;">example PHP:</span>  input validation of an IP with &quot;filter_var()&quot; function<br />    <div class="codebox"><pre>if (filter_var($_GET[&#39;ip&#39;], FILTER_VALIDATE_IP)) {<br />    // call function<br />} else {<br />    // deny request<br />}</pre></div><br /><span style="color:#a52a2a;">example custom code JavaScript:</span> input validation of an ip with test() function.<br />    This can be implemented both on the Front and Back End with Node.js<br />    <div class="codebox"><pre>if(/^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(ip)){<br />    // call function<br />}<br />else{<br />    // deny request<br />}</pre></div><br /><strong><h3>Input Sanitization</h3></strong><br />• Input sanitization, means removing any non-necessary special characters from the user input. <br />• Input sanitization is always performed after input validation. Even after we validated that the provided user input is in the proper format, we should still perform sanitization and <span style="text-decoration:underline;">remove any special characters not required for the specific format</span>, as there are cases where <span style="color:#ffa500;">input validation</span> may fail (e.g., a bad regex).<br />   ◇ Blacklisting certain words and looking for them in the user input is not a good enough approach to preventing injections<br /> and we should use built-in functions to remove any special characters.<br /><span style="color:#a52a2a;">example PHP:</span> preg_replace() to remove any special characters from the user input<br />    <div class="codebox"><pre>$ip = preg_replace(&#39;/[^A-Za-z0-9.]/&#39;, &#39;&#39;, $_GET[&#39;ip&#39;]);</pre></div><br />    the above regex only allows alphanumerical characters (A-Za-z0-9) and allows a dot character (.) as required for IPs. Any other characters will be removed from the string.<br /><span style="color:#a52a2a;">example Javascript:</span> replace() to remove any special characters from the user input (it does the same thing of the PHP code above)<br />    <div class="codebox"><pre>var ip = ip.replace(/[^A-Za-z0-9.]/g, &#39;&#39;);</pre></div><br /><span style="color:#a52a2a;">example Javascript:</span> DOMPurify library for a NodeJS back-end<br />    <div class="codebox"><pre>import DOMPurify from &#39;dompurify&#39;;<br />var ip = DOMPurify.sanitize(ip);</pre></div><code><br /></code><br /><span style="text-decoration:underline;">How Allow special characters</span><br />However remember that escaping special characters is not considered a secure practice, as it can often be bypassed through various techniques.<br />• PHP: use a function (like “filter_var()”) for input validation, and use the &quot;escapeshellcmd&quot; filter to escape any special characters, so they cannot cause any injections<br />• NodeJS: use escape(ip) function. <a href="https://www.geeksforgeeks.org/javascript-escape-function/">https://www.geeksforgeeks.org/javascript-escape-function/</a><br /><br /><br /><br /><strong><h3>Server Configuration</h3></strong><br />Finally, we should make sure that our back-end server is securely configured to reduce the impact in the event that the webserver is compromised. Some of the configurations we may implement are:<br />• Use the web server&#39;s built-in Web Application Firewall (e.g., in Apache <code>mod_security</code>), in addition to an external WAF (e.g. <code>Cloudflare</code>, <code>Fortinet</code>, <code>Imperva</code>..)<br />• Abide by the <a href="https://en.wikipedia.org/wiki/Principle_of_least_privilege">Principle of Least Privilege (PoLP)</a> by running the web server as a low privileged user (e.g. <code>www-data</code>)<br />• Prevent certain functions from being executed by the web server (e.g., in PHP <code>disable_functions=system,...</code>)<br />• Limit the scope accessible by the web application to its folder (e.g. in PHP <code>open_basedir = &#39;/var/www/html&#39;</code>)<br />• Reject double-encoded requests and non-ASCII characters in URLs<br /></div>
</body>
</html>
