<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Bypass with: Path Truncation</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>Bypass with: Path Truncation</h1><br/><strong><span style="color:#9141ac;">Path Truncation</span></strong><br />Behaviours(limitations) of PHP(&lt; 5.3/5.4) that allow this vulnerability:<br />   ◇ defined <span style="color:#1c71d8;text-decoration:underline;">strings have a maximum length of 4096 characters</span>, likely due to the limitation of 32-bit systems.<br />      If a longer string is passed, it will simply be truncated, and any characters after the maximum length will be ignored.<br />   ◇ PHP <span style="color:#ff7800;text-decoration:underline;">remove trailing slashes</span><span style="color:#ff7800;"> and</span><span style="color:#ff7800;text-decoration:underline;"> single dots</span> in path names<br />      ▪ remove of single dots: <br />         - /etc/passwd/<code>.</code> → then the <code>/.</code> would also be truncated → /etc/passwd<br />         -  <code>.</code> in the middle of the path would also be disregarded /etc/<code>.</code>/passwd → /etc//passwd<br />      ▪  PHP (and Linux systems in general) remove multiple slashes in the path<br />         -  <code>///</code>/etc/passwd →  /etc/passwd<br />If we combine both of these PHP limitations together(<span style="color:#1c71d8;text-decoration:underline;">max string length</span> + <span style="color:#ff7800;text-decoration:underline;">remove trailing slashes and single dots</span>):<br />	We can create very long strings that evaluate to a correct path. <br />	<span style="text-decoration:underline;">Whenever we reach the 4096 character limitation, the appended extension (.php) would be truncated</span>, and we would have a path without an appended extension. <br /><span style="text-decoration:underline;">Note:</span> we would also need to start the path with a <span style="color:#2ec27e;">non-existing directory</span> for this technique to work.<br /><br />• OPTION1 increase the number of <code>./</code><br />	      <code>?language=</code><code><span style="color:#2ec27e;">non_existing_directory</span></code><code>/../../../etc/passwd/./././.[./ REPEATED ~2048 times]</code><br /><br />	To automate the creation of  <code>./</code> 2048 times (total of 4096 characters):<br />	<div class="codebox"><pre>$ echo -n &quot;non_existing_directory/../../../etc/passwd/&quot; &amp;&amp; for i in {1..2048}; do echo -n &quot;./&quot;; done</pre></div><code><br /></code>		<code>non_existing_directory/../../../etc/passwd/./././&lt;SNIP&gt;././././<br /></code>	The number of ./ does not to have exactly necessay 2048 but also greater (~3000) or a little bit less (~2040) the important thing is that we exceed the number of 4096 of the string to trigger the vulnerability<br /><br />• OPTION2 increase the number of <code>../</code>:<br />	Instead of increase the number of <code>./</code> we may also increase the count of <code>../</code>, as adding more would still land us in the root directory.<br />	However, if we use this method, we should calculate the full length of the string to ensure only .php gets truncated and not our requested file at the end of the string (/etc/passwd). This is why it would be easier to use the first method.</div>
</body>
</html>
