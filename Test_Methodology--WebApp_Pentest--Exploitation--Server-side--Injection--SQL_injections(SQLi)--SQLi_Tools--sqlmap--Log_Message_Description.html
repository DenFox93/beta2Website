<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Log Message Description</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>Log Message Description</h1><br/><br />The following are some of the most common messages usually found during a scan of SQLMap, along with an example of each from the previous exercise and its description<span style="color:#a4b1cd;">.</span><br /><br />• <strong>URL content is stable</strong><br />    <a href=""><img src="images/2532-1.png" alt="images/2532-1.png" /></a><br />    This means that there are no major changes between responses in case of continuous identical requests. This is important from the automation point of view since, in the event of stable responses, it is easier to spot differences caused by the potential SQLi attempts. While stability is important, SQLMap has advanced mechanisms to automatically remove the potential &quot;noise&quot; that could come from potentially unstable targets.<br /><br />• <strong>Parameter appears to be dynamic</strong><br />    <a href=""><img src="images/2532-2.png" alt="images/2532-2.png" /></a><br />    It is always desired for the tested parameter to be &quot;dynamic,&quot; as it is a sign that any changes made to its value would result in a change in the response; hence the parameter may be linked to a database. In case the output is &quot;static&quot; and does not change, it could be an indicator that the value of the tested parameter is not processed by the target, at least in the current context.<br /><br />• <strong>Parameter might be injectable</strong><br />    <a href=""><img src="images/2532-3.png" alt="images/2532-3.png" /></a><br />    This is not proof of SQLi, but just an indication that the detection mechanism has to be proven in the subsequent run.<br /><br />• <strong>Parameter might be vulnerable to XSS attacks</strong><br />    <a href=""><img src="images/2532-4.png" alt="images/2532-4.png" /></a><br />    While it is not its primary purpose, SQLMap also runs a quick heuristic test for the presence of an XSS vulnerability. In large-scale tests, where a lot of parameters are being tested with SQLMap, it is nice to have these kinds of fast heuristic checks, especially if there are no SQLi vulnerabilities found.<br /><br />• <strong>Back-end DBMS is &#39;...&#39;</strong><br />    <a href=""><img src="images/2532-5.png" alt="images/2532-5.png" /></a><br />    In a normal run, SQLMap tests for all supported DBMSes. In case that there is a clear indication that the target is using the specific DBMS, we can narrow down the payloads to just that specific DBMS.<br /><br />• <strong>Level/risk values</strong><br />    <a href=""><img src="images/2532-6.png" alt="images/2532-6.png" /></a><br />    If there is a clear indication that the target uses the specific DBMS, it is also possible to extend the tests for that same specific DBMS beyond the regular tests.<br />    This basically means running all SQL injection payloads for that specific DBMS, while if no DBMS were detected, only top payloads would be tested.<br /><br />• <strong>Reflective values found</strong><br />    <a href=""><img src="images/2532-7.png" alt="images/2532-7.png" /></a><br />    Just a warning that parts of the used payloads are found in the response. This behavior could cause problems to automation tools, as it represents the junk. However, SQLMap has filtering mechanisms to remove such junk before comparing the original page content.<br /><br />• <strong>Parameter appears to be injectable</strong><br />    <a href=""><img src="images/2532-8.png" alt="images/2532-8.png" /></a><br />    This message indicates that the parameter appears to be injectable, though there is still a chance for it to be a false-positive finding. In the case of boolean-based blind and similar SQLi types (e.g., time-based blind), where there is a high chance of false-positives, at the end of the run, SQLMap performs extensive testing consisting of simple logic checks for removal of false-positive findings.<br />    Additionally, with --string=&quot;luther&quot; indicates that SQLMap recognized and used the appearance of constant string value luther in the response for distinguishing TRUE from FALSE responses. This is an important finding because in such cases, there is no need for the usage of advanced internal mechanisms, such as dynamicity/reflection removal or fuzzy comparison of responses, which cannot be considered as false-positive.<br /><br />• <strong>Time-based comparison statistical model</strong><br />    <a href=""><img src="images/2532-9.png" alt="images/2532-9.png" /></a><br />    SQLMap uses a statistical model for the recognition of regular and (deliberately) delayed target responses. For this model to work, there is a requirement to collect a sufficient number of regular response times. This way, SQLMap can statistically distinguish between the deliberate delay even in the high-latency network environments.<br /><br />• <strong>Extending UNION query injection technique tests</strong><br />    <a href=""><img src="images/2532-10.png" alt="images/2532-10.png" /></a><br />    UNION-query SQLi checks require considerably more requests for successful recognition of usable payload than other SQLi types. To lower the testing time per parameter, especially if the target does not appear to be injectable, the number of requests is capped to a constant value (i.e., 10) for this type of check. However, if there is a good chance that the target is vulnerable, especially as one other (potential) SQLi technique is found, SQLMap extends the default number of requests for UNION query SQLi, because of a higher expectancy of success.<br /><br />• <strong>Technique appears to be usable</strong><br />    <a href=""><img src="images/2532-11.png" alt="images/2532-11.png" /></a><br />    As a heuristic check for the UNION-query SQLi type, before the actual UNION payloads are sent, a technique known as ORDER BY is checked for usability. In case that it is usable, SQLMap can quickly recognize the correct number of required UNION columns by conducting the binary-search approach.<br />    Note that this depends on the affected table in the vulnerable query.<br /><br /><br />• <strong>Parameter is vulnerable</strong><br />    <a href=""><img src="images/2532-12.png" alt="images/2532-12.png" /></a><br />    This is one of the most important messages of SQLMap, as it means that the parameter was found to be vulnerable to SQL injections. In the regular cases, the user may only want to find at least one injection point (i.e., parameter) usable against the target. However, if we were running an extensive test on the web application and want to report all potential vulnerabilities, we can continue searching for all vulnerable parameters.<br /><br />• <strong>Sqlmap identified injection points</strong><br />    <a href=""><img src="images/2532-13.png" alt="images/2532-13.png" /></a><br />    Following after is a listing of all injection points with type, title, and payloads, which represents the final proof of successful detection and exploitation of found SQLi vulnerabilities. It should be noted that SQLMap lists only those findings which are provably exploitable (i.e., usable).<br /><br />• <strong>Data logged to text files</strong><br />    <a href=""><img src="images/2532-14.png" alt="images/2532-14.png" /></a><br />    This indicates the local file system location used for storing all logs, sessions, and output data for a specific target - in this case, www.example.com. After such an initial run, where the injection point is successfully detected, all details for future runs are stored inside the same directory&#39;s session files. This means that SQLMap tries to reduce the required target requests as much as possible, depending on the session files&#39; data.<br /></div>
</body>
</html>
