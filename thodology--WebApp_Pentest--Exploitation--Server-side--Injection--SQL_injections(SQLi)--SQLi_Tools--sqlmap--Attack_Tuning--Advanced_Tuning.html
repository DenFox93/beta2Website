<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Advanced Tuning</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>Advanced Tuning</h1><br/><br />With the following options we can set when we have TRUE conditions<br /><br />• <strong>Status Codes</strong> (--code=[statusCode])<br />For example, when dealing with a huge target response with a lot of dynamic content, subtle differences between TRUE and FALSE responses could be used for detection purposes.<br />If the difference between TRUE and FALSE responses can be seen in the HTTP codes (e.g. 200 for TRUE and 500 for FALSE), the option --code could be used to fixate the detection of TRUE responses to a specific HTTP code (e.g. --code=200).<br /><br />• <strong>Titles</strong> (--title=[&lt;titleTag&gt;)<br />If the difference between responses can be seen by inspecting the HTTP page titles, the switch --titles could be used to instruct the detection mechanism to base the comparison based on the content of the HTML tag &lt;title&gt;.<br /><br />• <strong>Strings</strong> (--string=&quot;successString&quot;)<br />In case of a specific string value appearing in TRUE responses (e.g. success), while absent in FALSE responses, the option --string could be used to fixate the detection based only on the appearance of that single value (e.g. --string=success).<br /><br />• <strong>Text-only</strong> (--text-only)<br />When dealing with a lot of hidden content, such as certain HTML page behaviors tags (e.g. &lt;script&gt;, &lt;style&gt;, &lt;meta&gt;, etc.), we can use the --text-only switch, which removes all the HTML tags, and bases the comparison only on the textual (i.e., visible) content.<br /><br />• <strong>Techniques</strong> (--technique=&quot;BEUSTQ&quot;)<br />In some special cases, we have to narrow down the used payloads only to a certain type. For example, if the time-based blind payloads are causing trouble in the form of response timeouts, or if we want to force the usage of a specific SQLi payload type, the option --technique can specify the SQLi technique to be used.<br />For example, if we want to skip the time-based blind and stacking SQLi payloads and only test for the boolean-based blind, error-based, and UNION-query payloads, we can specify these techniques with --technique=BEU.<br />Check the chapter <a href="st_Methodology--WebApp_Pentest--Exploitation--Server-side--Injection--SQL_injections(SQLi)--SQLi_Tools--sqlmap--Supported_Injection_Types.html">Supported Injection Types</a><br /><br />• <strong>UNION SQLi Tuning</strong><br />   ◇ --union-cols=[N] → In some cases, UNION SQLi payloads require extra user-provided information to work. If we can manually find the exact number of columns of the vulnerable SQL query, we can provide this number to SQLMap with the option --union-cols (e.g. --union-cols=17).<br />   ◇ --union-char=[value] → In case that the default &quot;dummy&quot; filling values used by SQLMap -NULL and random integer are not compatible with values from results of the vulnerable SQL query, we can specify an alternative value instead (e.g. --union-char=&#39;a&#39;).<br />   ◇ --union-from=[table] → In case there is a requirement to use an appendix at the end of a UNION query in the form of the FROM &lt;table&gt; (e.g., in case of Oracle), we can set it with the option --union-from (e.g. --union-from=users).<br />    Failing to use the proper FROM appendix automatically could be due to the inability to detect the DBMS name before its usage.<br /></div>
</body>
</html>
