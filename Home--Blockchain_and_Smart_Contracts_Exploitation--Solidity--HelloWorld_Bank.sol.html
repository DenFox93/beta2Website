<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>HelloWorld_Bank.sol</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>HelloWorld_Bank.sol</h1><br/>HelloWorld_Bank.sol → <a href="https://github.com/cclabsInc/BlockChainExploitation/blob/master/2020_BlockchainFreeCourse/HelloWorld_Bank.sol">https://github.com/cclabsInc/BlockChainExploitation/blob/master/2020_BlockchainFreeCourse/HelloWorld_Bank.sol</a><br /><div class="codebox"><pre>pragma solidity 0.6.6; <br /><br /><span style="color:#0088ff;font-weight:400">//creation of the contract</span><br />contract HelloWorld_Bank{<br />    <span style="color:#0088ff;font-weight:400">//owner will be the contracts administrator which is not explicitly defined here,</span><br />    <span style="color:#0088ff;font-weight:400">//but instead defined in the next chunk of code in the constructor</span><br />    address public owner;<br />    <span style="color:#0088ff;font-weight:400">//Mappings are similar to a dictionary lookup. It is a key value pair where in this case the address is mapped to a uint value.</span><br />    <span style="color:#0088ff;font-weight:400">//  The key is the address of the user, while the value is the users balance within the contract.</span><br />    <span style="color:#0088ff;font-weight:400">//  So, if you were to perform a dictionary lookup of a user’s address you would be provided back their bank balance.</span><br />    <span style="color:#0088ff;font-weight:400">//You will also note that this is a private variable meaning that you cannot retrieve this value directly outside of the contract</span><br />    <span style="color:#0088ff;font-weight:400">//  by referencing it. However, private variables as we will in later chapters are not as private as we think on the blockchain</span><br />    <span style="color:#0088ff;font-weight:400">//In this case case we are mapping an address of someone that interacting with the blockchain to a uint value(balance)</span><br />    mapping (address =&gt; uint) private balances;<br />    <br />    <span style="color:#0088ff;font-weight:400">//The constructor runs one time when the contract is deployed and will set things up for the contract.</span><br />    <span style="color:#0088ff;font-weight:400">//In this case we are creating a constructor which is payable meaning that when you deploy the contract you can send Ethereum </span><br />    <span style="color:#0088ff;font-weight:400">//  and that Ethereum will be stored within the contract’s balance. </span><br />    <span style="color:#0088ff;font-weight:400">//This is useful if the contract requires a balance for some of its actions right out of the gate.</span><br />    constructor () public payable {<br />        <span style="color:#0088ff;font-weight:400">//Defining an owner in the constructor is common convention used in solidity to have </span><br />        <span style="color:#0088ff;font-weight:400">//an administrative user to limit usage of specific functionality.</span><br />        <span style="color:#0088ff;font-weight:400">//Usually, authorization of functionality is handled in a security library, for example Openzeppelin, </span><br />        <span style="color:#0088ff;font-weight:400">//which we will cover extensively when fixing smart contract vulnerabilities.</span><br />        <br />        <span style="color:#0088ff;font-weight:400">//This is a way for the contract to set an administrative user when the contract is created. </span><br />        <span style="color:#0088ff;font-weight:400">//Since the constructor runs only one time, it’s a good place to set an initial user. </span><br />        <span style="color:#0088ff;font-weight:400">//Often you will see this paired with a change owner function that is protected by the owner’s authorization level </span><br />        <span style="color:#0088ff;font-weight:400">//and allows the current owner to set a new administrative user.</span><br />        <span style="color:#0088ff;font-weight:400">//The msg.sender variable in solidity is simply the users address who called the function,</span><br />        <span style="color:#0088ff;font-weight:400">//or in this case the user who published the contract initially.</span><br />        <span style="color:#0088ff;font-weight:400">//This is tied to the user’s public address they use for transactions</span><br />        <br />        <span style="color:#0088ff;font-weight:400">//Each time a user interacts with a contract, their address is known by the contract </span><br />        <span style="color:#0088ff;font-weight:400">//as the msg.sender value and this address is used to associate values with their account sort of like a session variable in a sense.</span><br />        <span style="color:#0088ff;font-weight:400">//You can use this value to map functionality to that user</span><br />        <br />        <span style="color:#0088ff;font-weight:400">//msg.sender value in this contract is used to set the Owner, validate the Owner, map balances on accounts and </span><br />        <span style="color:#0088ff;font-weight:400">//transfer value back to the user.</span><br />        owner = msg.sender; <br />    }<br />    <br /><br />    <span style="color:#0088ff;font-weight:400">//isOwner() Check if the user interacting with a contract is the owner of the application.</span><br />    <span style="color:#0088ff;font-weight:400">//  It checks this by returning true if the msg.sender value equals the current owners address. </span><br />    <span style="color:#0088ff;font-weight:400">//This is how the application enforces its authorization level on administrative users.</span><br />    function isOwner () public view returns(<span style="color:#7f0044;font-weight:400">bool</span>) {<br />        <span style="color:#ff9d00;font-weight:700">return</span> msg.sender == owner;<br />    }<br />    <br />    <br />    <span style="color:#0088ff;font-weight:400">//This is a modifier(not a function), this mean we can check within the definition of a function </span><br />    <span style="color:#0088ff;font-weight:400">//  instead of the body of the function as you can check below with the withdrawAll function</span><br />    <br />    <span style="color:#0088ff;font-weight:400">//using require(isOwner) in the beginning of a function the function would refuse to run the rest of its code if the user</span><br />    <span style="color:#0088ff;font-weight:400">//  calling the contract was not the owner;</span><br />    <span style="color:#0088ff;font-weight:400">//_;  --&gt; this value simply means continue running calling code as normal within the function provided the require modifier returned true.</span><br />    <br />    modifier onlyOwner() {<br />        require(isOwner());<br />        _;<br />    }<br />    <br />    <br />    <span style="color:#0088ff;font-weight:400">//deposit function is used for filling the account of the concract with Ether from an external account </span><br />    <span style="color:#0088ff;font-weight:400">//You can notice that the definition of the function deposit has the words public and payable.</span><br />    <span style="color:#0088ff;font-weight:400">//This because in order to deposit value to an account the function must be marked as a payable function. </span><br />    <span style="color:#0088ff;font-weight:400">//This goes for addresses as well, when using addresses within value transfers those addresses must also be marked as payable.</span><br />    <span style="color:#0088ff;font-weight:400">//This was something that was added the Solidity as of version 5, prior to version 5 if you are auditing code</span><br />    <span style="color:#0088ff;font-weight:400">//you will not see this keyword required within all portions of value transfer events.</span><br />    <br />    <span style="color:#0088ff;font-weight:400">//The deposit function need to be public, because we need to call it,</span><br />    <span style="color:#0088ff;font-weight:400">//It has a require line, a conditional check that if it fails the transaction will halt and revert back to the state before it was called.</span><br />    <span style="color:#0088ff;font-weight:400">//  In this instance, if the value is not a positive value, it will fail and the function will return an error.</span><br />    <span style="color:#0088ff;font-weight:400">//  If the value is indeed a positive number,</span><br />    <span style="color:#0088ff;font-weight:400">//the next line will run and increase the account value of the user by the value that was sent.</span><br />    function deposit() public payable {<br />        require((balances[msg.sender] + msg.value) &gt;= balances[msg.sender]);<br />        balances[msg.sender] += msg.value;<br />    }<br />    <br />    <span style="color:#0088ff;font-weight:400">//withdraw function used for removing your Ether from the contract.</span><br />    <span style="color:#0088ff;font-weight:400">//Require that the amount to be withdrawn is less than or equal to the account balance of that user. </span><br />    <span style="color:#0088ff;font-weight:400">//  If this check fails and the user does not have a high enough balance for the withdraw, then transaction returns an error.</span><br />    <span style="color:#0088ff;font-weight:400">//  If it succeeds, then the function continue the execution and</span><br />    <span style="color:#0088ff;font-weight:400">//it decrease the balance of the user internally </span><br />    <span style="color:#0088ff;font-weight:400">//followed by transferring the approved amount back to the users account address.</span><br />    function withdraw (uint withdrawAmount) public {<br />        require (withdrawAmount &lt;= balances[msg.sender]);<br />        balances[msg.sender] -= withdrawAmount;<br />        msg.sender.transfer(withdrawAmount);<br />    }<br />  <br />    <span style="color:#0088ff;font-weight:400">//We can see that this function has the onlyOwner modifier created in the beginning of the contract.</span><br />    <span style="color:#0088ff;font-weight:400">//When this modifier is added to the function definition, it will run the code within isOwner which checks if the user is the original contract owner </span><br />    <span style="color:#0088ff;font-weight:400">//created in the constructor when the contract was deployed.</span><br />    function withdrawAll() public onlyOwner {<br />        msg.sender.transfer(address(this).balance);<br />    }<br />    <br />    <span style="color:#0088ff;font-weight:400">//function that returns the balance of the user who calls the function.</span><br />    <span style="color:#0088ff;font-weight:400">//You will notice that within the function definition it uses the “view” keyword indicating that it is not modifying anything</span><br />    <span style="color:#0088ff;font-weight:400">//  and should not incur fees for processing</span><br />    function getBalance () public view returns (uint){<br />        <span style="color:#ff9d00;font-weight:700">return</span> balances[msg.sender];<br />    }<br />}</pre></div><br /><br />Bibliography:<br />• <a href="http://console-cowboys.blogspot.com/2020/08/smart-contract-hacking-chapter-2.html">http://console-cowboys.blogspot.com/2020/08/smart-contract-hacking-chapter-2.html</a><br /></div>
</body>
</html>
