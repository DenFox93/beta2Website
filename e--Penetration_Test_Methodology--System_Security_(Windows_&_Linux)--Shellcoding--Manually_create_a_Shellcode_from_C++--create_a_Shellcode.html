<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>create a Shellcode</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>create a Shellcode</h1><br/>1. <strong>C++ code</strong><br />In this example we will use the ShellExecute function<br /><div class="codebox"><pre><span style="color:#7f0044;font-weight:700">#include &lt;windows.h&gt;</span><br /><span style="color:#7f0044;font-weight:400">int</span> main(<span style="color:#7f0044;font-weight:400">int</span> argc, <span style="color:#7f0044;font-weight:400">char</span>** argv)<br />{<br />ShellExecute(<span style="color:#ff0044;font-weight:400">0</span>,<span style="color:#3ad900;font-weight:400">&quot;open&quot;</span>,<span style="color:#3ad900;font-weight:400">&quot;cmd&quot;</span>,<span style="color:#ff0044;font-weight:400">0</span>,<span style="color:#ff0044;font-weight:400">0</span>,<span style="color:#ff0044;font-weight:400">3</span>);<br />}</pre></div><br />function <a href="https://docs.microsoft.com/en-us/windows/win32/api/shellapi/nf-shellapi-shellexecutea?redirectedfrom=MSDN">ShellExecute</a>(alias ShellExecuteA) called with these parameters <span style="text-decoration:underline;">will spawn a new command prompt</span> and will maximize the window<br />    Below we can see its syntax:<br />    <div class="codebox"><pre>HINSTANCE ShellExecuteA(<br />  HWND   hwnd,                     <span style="color:#0088ff;font-weight:400">//displaying a UI or error messages</span><br />  LPCSTR lpOperation,              <span style="color:#0088ff;font-weight:400">//specifies the action to be performed</span><br />  LPCSTR lpFile,                   <span style="color:#0088ff;font-weight:400">//string that specifies the file or object to execute on which to execute the specified lpOperation</span><br />  LPCSTR lpParameters,             <span style="color:#0088ff;font-weight:400">//parameters to be passed to the application lpfile</span><br />  LPCSTR lpDirectory,              <span style="color:#0088ff;font-weight:400">/*string that specifies the default (working) directory for the action;<br />                                   if a relative path is provided at lpFile, do not use a relative path for lpDirectory */</span><br />  INT    nShowCmd                  <span style="color:#0088ff;font-weight:400">//specify how an application is to be displayed when it is opened</span><br />);</pre></div><br /><br />2. <strong>Compile the C++(.cpp) file</strong><br /><div class="codebox"><pre>g++ -m32 c++.cpp -o c++.exe</pre></div><br />or directly from Dev-C++ or others IDE<br /><br />3. <strong>Decompile EXE with Immunity Debugger</strong><br />We can decompile it also with <a href="Home--Penetration_Test_Methodology--System_Security_(Windows_&_Linux)--Assemblers,_Debuggers_and_Tools--Decompiler--objdump_(Dev-C++).html">objdump</a> but is very impractical. <br /><a href="file://G:/Other computers/Yoga 520/CherryTree/screenshots2/PTP-elearnsecurity/1. System Security/4 - Shellcoding/ShellExecute_decompiled.png"><img src="images/534-1.png" alt="images/534-1.png" /></a><br />The <span style="color:#ff8700;">parameters of the function are pushed in the reverse order</span>, in this way we will have the last parameter pushed(the first in C++ code) <span style="text-decoration:underline;">at the top of the </span><strong><span style="text-decoration:underline;">stack</span></strong><br /><a href=""><img src="images/534-2.png" alt="images/534-2.png" /></a><br /><br />4. <strong>Create the Shellcode</strong><br />    4.1 <strong>PUSH parameters of the function to the stack</strong><br />    The parameters have to be PUSHed in the <span style="text-decoration:underline;">reverse order</span> found in C++; <br />    ◇ PUSH opcode is <span style="color:#00ff79;">68 (\x68)</span> for word and dword<br />    ◇ PUSH opcode id <span style="color:#8eff00;">6A (\x6A)</span> for a byte(e.g.: integer,..)<br />        4.1.1 <strong>Translate Strings from Assembly to Opcode</strong><br />            4.1.1.1 <strong>Manually </strong> <br />           ◇ <span style="text-decoration:underline;">split</span> string ASCII representation into groups of 4 characters(4 bytes) since we will have to push them to the stack<br />           ◇ <span style="text-decoration:underline;">convert</span> the ASCII characters into hexadecimal values (online: <a href="http://www.asciitohex.com/">asciitohex</a>, <a href="http://www.rapidtables.com/convert/number/ascii-to-hex.htm">rapidtable</a>); before each hexadecimal value add the \x notation before each byte, \x in C/C++ indicates a hexadecimal character escape<br />           ◇ <span style="text-decoration:underline;">Terminate the string</span>(not the group of 4 characters) with \x00 otherwise the function parameter will load all the data in the stack (or until it find another \x00);<br />              ▪ if \x00 is not enter in the last group of character(it count as character) we have 2 possibilities:<br />                 - we can use the PUSH opcode 68 and create a new group of 4 character, put \x00 at the end and fill the remaining part with \x20 (hexadecimal value of the space character)<br />                    <span style="color:#a5452a;">example:</span> <code><span style="color:#00ff79;">\x68</span></code><code>\x20\x20\x20\x00</code><br />                 - we can use the PUSH opcode 6A and put directly \x00<br />                    <span style="color:#a5452a;">example:</span> <code><span style="color:#8eff00;">\x6A</span></code><code>\x00</code><br />            4.1.1.2 <strong>Automatically  with tools</strong><br />              ◇ online tools: <a href="https://defuse.ca/online-x86-assembler.htm#disassembly">defuse.ca</a><br />              ◇ offline tools: Metasm, Immunity...<br />              ◇ Immunity Debugger → double-click on a random instruction in the main panel and type the ASM code that we want to assemble in the pop-up window that appears<br />              <br />        4.1.2 <strong>If the function require a pointer to the string and not the string itself</strong><br />         ◇  We have to save a pointer to the string using a register. <br />            Because when we push a string to the stack <span style="color:#ff0000;">ESP</span> is automatically updated and point to our string; we can save the value of <span style="color:#ff0000;">ESP</span>(current stack position) into a <span style="color:#ff8700;">register</span>(such as EBX or ECX). To save the pointer of <span style="color:#ff0000;">ESP</span> into another <span style="color:#ff8700;">register</span> we can use an instruction right this <code>mov ebx, </code><code><span style="color:#ff0000;">esp</span></code><br />            <span style="color:#a5452a;">example:</span><br />            <div class="codebox"><pre>\x8B\xDC      <span style="color:#0088ff;font-weight:400">// mov ebx, esp</span></pre></div><br />            To translate these operations we can use an online tool like: <a href="https://defuse.ca/online-x86-assembler.htm">https://defuse.ca/online-x86-assembler.htm</a><br />         ◇ If there are not other parameters to pass to the function we can PUSH the register<br />             <span style="color:#a5452a;">example:</span><br />            <div class="codebox"><pre>\x53      <span style="color:#0088ff;font-weight:400">// PUSH EBX</span></pre></div><br />            <br />        4.1.3 <strong>Pass integer values to the function</strong><br />        We have different ways to do it:<br />         ◇ PUSH it directly into the stack<br />            <span style="color:#a5452a;">example:</span><br />            <div class="codebox"><pre>\x6A\x05      <span style="color:#0088ff;font-weight:400">// PUSH 5</span></pre></div><br />         ◇ move the integer into a register and then PUSH the register<br />            <span style="color:#a5452a;">example:</span><br />            <div class="codebox"><pre>\x33\xC0      <span style="color:#0088ff;font-weight:400">// xor eax, eax</span><br />\x50          <span style="color:#0088ff;font-weight:400">// PUSH EAX =&gt; pushes 0</span></pre></div><br />         ◇ zero out a register and then increment the register of n times (n is the value of the integer)<br />         <br />    4.2 <strong>Call the function</strong><br />      ◇ find the address of the function that we want call, example with <a href="ws_&_Linux)--Shellcoding--Manually_create_a_Shellcode_from_C++--Search_for_the_address_of_function_in_executable-dll_that_we_want_to_call.html">arwin</a><br />      ◇ move(MOV) the address value into a register and then CALL it<br />        <div class="codebox"><pre>\xB8\x78\x70\x30\x76     <span style="color:#0088ff;font-weight:400">// MOV EAX,76307078 - address of ShellExecuteA</span><br />\xff\xD0                 <span style="color:#0088ff;font-weight:400">// CALL EAX</span></pre></div><br /><br />5. <strong>Test if the Shellcode works</strong><br />To test if the shellcode works we need to Compile the C++ file seen also here <br />Because ASLR is enabled(address randomization) for the library Shell32.dll the below code work only on the Windows 7 machine tested <br /><div class="codebox"><pre><span style="color:#7f0044;font-weight:700">#include &lt;windows.h&gt;</span>        <span style="color:#0088ff;font-weight:400">// needed to load Shell32.dll</span><br /><span style="color:#7f0044;font-weight:400">char</span> code[] = <br /><span style="color:#3ad900;font-weight:400">&quot;\x68\x63\x6d\x64\x00&quot;</span>      <span style="color:#0088ff;font-weight:400">// PUSH &quot;cmd&quot; - string already terminated</span><br /><span style="color:#3ad900;font-weight:400">&quot;\x8B\xDC&quot;</span>                  <span style="color:#0088ff;font-weight:400">// MOV EBX, ESP; means copy the pointer to &quot;cmd&quot; in EBX</span><br /><span style="color:#3ad900;font-weight:400">&quot;\x6A\x00&quot;</span> 					<span style="color:#0088ff;font-weight:400">// PUSH the string terminator \x00 for &quot;open&quot;</span><br /><span style="color:#3ad900;font-weight:400">&quot;\x68\x6f\x70\x65\x6e&quot;</span> 		<span style="color:#0088ff;font-weight:400">// PUSH &quot;open&quot; onto the stack</span><br /><span style="color:#3ad900;font-weight:400">&quot;\x8B\xCC&quot;</span> 					<span style="color:#0088ff;font-weight:400">// MOV ECX, ESP; means copy the pointer to &quot;open&quot; in ECX</span><br /><span style="color:#3ad900;font-weight:400">&quot;\x6A\x03&quot;</span> 					<span style="color:#0088ff;font-weight:400">// PUSH 3: Push the last argument with value 3 or also called SW_SHOWMAXIMIZED</span><br /><span style="color:#3ad900;font-weight:400">&quot;\x33\xC0&quot;</span> 					<span style="color:#0088ff;font-weight:400">// xor eax, eax; zero out eax</span><br /><span style="color:#3ad900;font-weight:400">&quot;\x50&quot;</span> 						<span style="color:#0088ff;font-weight:400">// PUSH EAX: push second to last argument - 0</span><br /><span style="color:#3ad900;font-weight:400">&quot;\x50&quot;</span> 						<span style="color:#0088ff;font-weight:400">// PUSH EAX: push third to last argument - 0</span><br /><span style="color:#3ad900;font-weight:400">&quot;\x53&quot;</span> 						<span style="color:#0088ff;font-weight:400">// PUSH EBX: push pointer to string &#39;cmd&#39;</span><br /><span style="color:#3ad900;font-weight:400">&quot;\x51&quot;</span> 						<span style="color:#0088ff;font-weight:400">// PUSH ECX: push pointer to string &#39;open&#39;</span><br /><span style="color:#3ad900;font-weight:400">&quot;\x50&quot;</span> 						<span style="color:#0088ff;font-weight:400">// PUSH EAX: push the first argument - 0</span><br /><span style="color:#3ad900;font-weight:400">&quot;\xB8\x78\x70\x30\x76&quot;</span> 		<span style="color:#0088ff;font-weight:400">// MOV EAX,76307078: move ShellExecuteA address into EAX</span><br /><span style="color:#3ad900;font-weight:400">&quot;\xff\xD0&quot;</span> 					<span style="color:#0088ff;font-weight:400">// CALL EAX: call the function ShellExecuteA</span><br />; 							<span style="color:#0088ff;font-weight:400">// Terminates the C instruction</span><br /><br /><br /><span style="color:#7f0044;font-weight:400">int</span> main(<span style="color:#7f0044;font-weight:400">int</span> argc, <span style="color:#7f0044;font-weight:400">char</span> **argv) <br />{ <br />	LoadLibraryA(<span style="color:#3ad900;font-weight:400">&quot;Shell32.dll&quot;</span>);    <span style="color:#0088ff;font-weight:400">// force the program to load Shell32.dll otherwhise </span><br />									<span style="color:#0088ff;font-weight:400">// the shellcode will jump to an empty location and the shellcode will fail</span><br />	<span style="color:#7f0044;font-weight:400">int</span> (*func)(); <br />	func = (<span style="color:#7f0044;font-weight:400">int</span> (*)()) code; <br />	(<span style="color:#7f0044;font-weight:400">int</span>)(*func)(); <br />}</pre></div><br /><br />6. <strong>Debug the Shellcode</strong><br />If we want debug the program once we have compiled it we can open the .exe with Immunity Debugger and this is the Shellcode injected. <br />The behavior it&#39;s the same of the part of code debugged at the point &quot;3. Decompile EXE with Immunity Debugger&quot;<br /><a href=""><img src="images/534-3.png" alt="images/534-3.png" /></a><br /><br />Her in the stack we can see the pointers that contain the addresses that actually store the strings<br /><a href=""><img src="images/534-4.png" alt="images/534-4.png" /></a><br /><br /></div>
</body>
</html>
