<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>XSS Prevention</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>XSS Prevention</h1><br/>Mitigating a XSS is about implementing:<br />• <strong>Input validation</strong> to filter the attack vectors as much as possible<br />• <strong>Context-aware output encoding</strong> to correctly and safely render users&#39; content on the web application pages<br />   ◇ Every time input supplied by the user is displayed in the web application output, it should be encoded.<br /><br /><br /><br /><br />The most important aspect of preventing XSS vulnerabilities is proper input sanitization and validation on both the front and back end.<br /><br /><strong><h3>Front-end</h3></strong><br />As the front-end of the web application is where most (but not all) of the user input is taken from, it is essential to sanitize and validate the user input on the front-end using JavaScript.<br /><br />• <strong>Input Validation</strong><br />   ◇ <strong>javascript</strong> (custom function)<br />	Not allow the user to submit the form if the email format is invalid.<br />	This code is test the email input field. It returning true or false whether it matches the Regex validation of an email format<br />	<div class="codebox"><pre>function validateEmail(email) {<br />    const re = /^(([^&lt;&gt;()[\]\\.,;:\s@\&quot;]+(\.[^&lt;&gt;()[\]\\.,;:\s@\&quot;]+)*)|(\&quot;.+\&quot;))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;<br />    return re.test($(&quot;#login input[name=email]&quot;).val());<br />}</pre></div><br /><br />• <strong>Input Sanitization</strong><br />	In addition to input validation, we should alway ensure that we do not allow any input with JavaScript code in it, by escaping any special characters. For this, we can utilize the DOMPurify JavaScript library, as follows:<br />   ◇ <strong>javascript</strong> (DomPurify.sanitize()) <br />	<div class="codebox"><pre>&lt;script type=&quot;text/javascript&quot; src=&quot;dist/purify.min.js&quot;&gt;&lt;/script&gt;<br />let clean = DOMPurify.sanitize( dirty );</pre></div><br />	This will escape any special characters with a backslash \, which should help ensure that a user does not send any input with special characters (like JavaScript code), which should prevent vulnerabilities like DOM XSS.<br /><br />• <strong>Direct Input</strong><br />   ◇ Always ensure to never use user input directly within certain HTML tags, like:<br />      1- JavaScript code <span style="color:#e01b24;">&lt;script&gt;&lt;/script&gt;</span><br />      2- CSS Style Code <span style="color:#e01b24;">&lt;style&gt;&lt;/style&gt;</span><br />      3- Tag/Attribute Fields <span style="color:#e01b24;">&lt;div name=&#39;INPUT&#39;&gt;&lt;/div&gt;</span><br />      4- HTML Comments <span style="color:#e01b24;">&lt;!-- --&gt;</span><br />	If user input goes into any of the above examples, it can inject malicious JavaScript code, which may lead to an XSS vulnerability.<br />   ◇ Avoid using using these functions that write raw text to the HTML code, if any user input goes into them, it may include malicious JavaScript code, which leads to an XSS vulnerability.:<br />      ▪  JavaScript functions that allow changing raw text of HTML fields, like:<br />         - DOM.innerHTML<br />         - DOM.outerHTML<br />         - document.write()<br />         - document.writeln()<br />         - document.domain<br />      ▪ jQuery functions:<br />         - html()<br />         - parseHTML()<br />         - add()<br />         - append()<br />         - prepend()<br />         - after()<br />         - insertAfter()<br />         - before()<br />         - insertBefore()<br />         - replaceAll()<br />         - replaceWith()<br /><br /><strong><h3>Back-end</h3></strong><br />To Prevent XSS Stored and XSS Reflected vulnerabilities we need to use measures on the back-end <br />These measures include: Input and Output Sanitization and Validation, Server Configuration, and Back-end Tools<br /><br />•<strong> Input Validation</strong><br />	Input validation in the back-end is quite similar to the front-end, and it uses Regex or library functions to ensure that the input field is what is expected.<br />   ◇ <strong>PHP</strong> (filter_var())<br />	E-mail validation on the PHP back-end server<br />	<div class="codebox"><pre>if (filter_var($_GET[&#39;email&#39;], FILTER_VALIDATE_EMAIL)) {<br />    // do task<br />} else {<br />    // reject input - do not display it<br />}</pre></div><br />   ◇ <strong>NodeJS backend (javascript)</strong>:<br />   	 For a NodeJS back-end, we can use the same JavaScript code mentioned earlier for the front-end.<br /><br /><strong>• Input Sanitization</strong><br />	When it comes to input sanitization, then the back-end plays a vital role, as front-end input sanitization can be easily bypassed by sending custom GET or POST requests. Luckily, there are very strong libraries for various back-end languages that can properly sanitize any user input, such that we ensure that no injection can occur.<br />	◇ <strong>PHP</strong> (addslashes())<br />		we can use the addslashes function to sanitize user input by escaping special characters with a backslash.<br />		<span style="text-decoration:underline;">Note:</span> In any case, direct user input (e.g. $_GET[&#39;email&#39;]) should never be directly displayed on the page, as this can lead to XSS vulnerabilities.<br />		<div class="codebox"><pre>addslashes($_GET[&#39;email&#39;])</pre></div><code><br /></code>   ◇ <strong>NodeJS backend</strong> javascript (DOMPurify)<br />	    For a NodeJS back-end, we can also use the <a href="https://github.com/cure53/DOMPurify">DOMPurify</a> library as we did with Input Sanitization in the front-end in javascript<br />		<div class="codebox"><pre>import DOMPurify from &#39;dompurify&#39;;<br />var clean = DOMPurify.sanitize(dirty);</pre></div><code><br /></code><br /><br /><br /><strong>• Output HTML Encoding</strong><br />    We have to encode any special characters into the HTML code, which is helpful if we need to display the entire user input without introducing an XSS vulnerability. <br />	◇ <strong>PHP</strong> (htmlspecialchars or the htmlentities functions): <span style="color:#865e3c;">Example Code</span><br />	    For a PHP back-end, we can use the htmlspecialchars or the htmlentities functions, which would encode certain special characters into their HTML codes (e.g. &lt; into &amp;lt), so the browser will display them correctly, but they will not cause any injection of any sort<br />        <div class="codebox"><pre>htmlentities($_GET[&#39;email&#39;]);</pre></div><code><br /></code>   ◇ <strong>NodeJS back-end javascript</strong> (html-entities)<br />       we can use any library that does HTML encoding, like html-entities, as follows:<br />        <div class="codebox"><pre>import encode from &#39;html-entities&#39;;<br />encode(&#39;&lt;&#39;); // -&gt; &#39;&amp;lt;&#39;</pre></div><code><br /></code><br /><br /><strong>• Server Configuration</strong><br />    There are certain back-end web server configurations that may help in preventing XSS attacks, such as:<br />      - Using HTTPS across the entire domain<br />      - Using XSS prevention headers, like <code>X-XSS-Protection</code>.<br />      - Using the appropriate Content-Type for the page, like <code>X-Content-Type-Options=nosniff</code>.<br />      - Using <code>Content-Security-Policy</code> options, like <code>script-src &#39;self&#39;</code>, which only allows locally hosted scripts.<br />      - Using the <code>HttpOnly</code> and <code>Secure</code> cookie flags to prevent JavaScript from reading cookies and only transport them over HTTPS.<br /><br />• <strong>WAF</strong><br />    Having a good Web Application Firewall (WAF) can significantly reduce the chances of XSS exploitation, as it will automatically detect any type of injection going through HTTP requests and will automatically reject such requests.<br /><br /></div>
</body>
</html>
